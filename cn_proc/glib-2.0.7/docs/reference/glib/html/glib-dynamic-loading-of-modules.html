<HTML
><HEAD
><TITLE
>Dynamic Loading of Modules</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.76b+
"><LINK
REL="HOME"
TITLE="GLib Reference Manual"
HREF="index.html"><LINK
REL="UP"
TITLE="GLib Core Application Support"
HREF="glib-core.html"><LINK
REL="PREVIOUS"
TITLE="Asynchronous Queues"
HREF="glib-asynchronous-queues.html"><LINK
REL="NEXT"
TITLE="Memory Allocation"
HREF="glib-memory-allocation.html"></HEAD
><BODY
CLASS="REFENTRY"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
BGCOLOR="#000000"
CELLPADDING="1"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
><FONT
COLOR="#FFFFFF"
SIZE="5"
>GLib Reference Manual</FONT
></TH
></TR
><TR
><TD
WIDTH="25%"
BGCOLOR="#C00000"
ALIGN="left"
><A
HREF="glib-asynchronous-queues.html"
><FONT
COLOR="#FFFFFF"
SIZE="3"
><B
>&#60;&#60;&#60; Previous Page</B
></FONT
></A
></TD
><TD
WIDTH="25%"
BGCOLOR="#C00000"
ALIGN="center"
><FONT
COLOR="#FFFFFF"
SIZE="3"
><B
><A
HREF="index.html"
><FONT
COLOR="#FFFFFF"
SIZE="3"
><B
>Home</B
></FONT
></A
></B
></FONT
></TD
><TD
WIDTH="25%"
BGCOLOR="#C00000"
ALIGN="center"
><FONT
COLOR="#FFFFFF"
SIZE="3"
><B
><A
HREF="glib-core.html"
><FONT
COLOR="#FFFFFF"
SIZE="3"
><B
>Up</B
></FONT
></A
></B
></FONT
></TD
><TD
WIDTH="25%"
BGCOLOR="#C00000"
ALIGN="right"
><A
HREF="glib-memory-allocation.html"
><FONT
COLOR="#FFFFFF"
SIZE="3"
><B
>Next Page &#62;&#62;&#62;</B
></FONT
></A
></TD
></TR
></TABLE
></DIV
><H1
><A
NAME="GLIB-DYNAMIC-LOADING-OF-MODULES">Dynamic Loading of Modules</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN7235"
></A
><H2
>Name</H2
>Dynamic Loading of Modules&nbsp;--&nbsp;portable method for dynamically loading 'plug-ins'.</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN7238"><H2
>Synopsis</H2
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>&#13;#include &lt;gmodule.h&gt;


struct      <A
HREF="glib-dynamic-loading-of-modules.html#GMODULE"
>GModule</A
>;
<A
HREF="glib-basic-types.html#GBOOLEAN"
>gboolean</A
>    <A
HREF="glib-dynamic-loading-of-modules.html#G-MODULE-SUPPORTED"
>g_module_supported</A
>              (void);
<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>*      <A
HREF="glib-dynamic-loading-of-modules.html#G-MODULE-BUILD-PATH"
>g_module_build_path</A
>             (const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *directory,
                                             const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *module_name);
<A
HREF="glib-dynamic-loading-of-modules.html#GMODULE"
>GModule</A
>*    <A
HREF="glib-dynamic-loading-of-modules.html#G-MODULE-OPEN"
>g_module_open</A
>                   (const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *file_name,
                                             <A
HREF="glib-dynamic-loading-of-modules.html#GMODULEFLAGS"
>GModuleFlags</A
> flags);
enum        <A
HREF="glib-dynamic-loading-of-modules.html#GMODULEFLAGS"
>GModuleFlags</A
>;
<A
HREF="glib-basic-types.html#GBOOLEAN"
>gboolean</A
>    <A
HREF="glib-dynamic-loading-of-modules.html#G-MODULE-SYMBOL"
>g_module_symbol</A
>                 (<A
HREF="glib-dynamic-loading-of-modules.html#GMODULE"
>GModule</A
> *module,
                                             const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *symbol_name,
                                             <A
HREF="glib-basic-types.html#GPOINTER"
>gpointer</A
> *symbol);
G_CONST_RETURN <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>* <A
HREF="glib-dynamic-loading-of-modules.html#G-MODULE-NAME"
>g_module_name</A
>         (<A
HREF="glib-dynamic-loading-of-modules.html#GMODULE"
>GModule</A
> *module);
void        <A
HREF="glib-dynamic-loading-of-modules.html#G-MODULE-MAKE-RESIDENT"
>g_module_make_resident</A
>          (<A
HREF="glib-dynamic-loading-of-modules.html#GMODULE"
>GModule</A
> *module);
<A
HREF="glib-basic-types.html#GBOOLEAN"
>gboolean</A
>    <A
HREF="glib-dynamic-loading-of-modules.html#G-MODULE-CLOSE"
>g_module_close</A
>                  (<A
HREF="glib-dynamic-loading-of-modules.html#GMODULE"
>GModule</A
> *module);
G_CONST_RETURN <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>* <A
HREF="glib-dynamic-loading-of-modules.html#G-MODULE-ERROR"
>g_module_error</A
>        (void);

const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>* (<A
HREF="glib-dynamic-loading-of-modules.html#GMODULECHECKINIT"
>*GModuleCheckInit</A
>)            (<A
HREF="glib-dynamic-loading-of-modules.html#GMODULE"
>GModule</A
> *module);
void        (<A
HREF="glib-dynamic-loading-of-modules.html#GMODULEUNLOAD"
>*GModuleUnload</A
>)                (<A
HREF="glib-dynamic-loading-of-modules.html#GMODULE"
>GModule</A
> *module);
#define     <A
HREF="glib-dynamic-loading-of-modules.html#G-MODULE-SUFFIX-CAPS"
>G_MODULE_SUFFIX</A
>
#define     <A
HREF="glib-dynamic-loading-of-modules.html#G-MODULE-EXPORT-CAPS"
>G_MODULE_EXPORT</A
>
#define     <A
HREF="glib-dynamic-loading-of-modules.html#G-MODULE-IMPORT-CAPS"
>G_MODULE_IMPORT</A
></PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN7276"
></A
><H2
>Description</H2
><P
>These functions provide a portable way to dynamically load object files
(commonly known as 'plug-ins').
The current implementation supports all systems that provide
an implementation of <TT
CLASS="FUNCTION"
>dlopen()</TT
> (e.g. Linux/Sun), as well as HP-UX via its
<TT
CLASS="FUNCTION"
>shl_load()</TT
> mechanism, and Windows platforms via DLLs.</P
><P
>A program which wants to use these functions must be linked to the
libraries output by the command <B
CLASS="COMMAND"
>pkg-config --libs gmodule-2.0</B
>.</P
><P
>To use them you must first determine whether dynamic loading
is supported on the platform by calling <A
HREF="glib-dynamic-loading-of-modules.html#G-MODULE-SUPPORTED"
>g_module_supported</A
>().
If it is, you can open a module with <A
HREF="glib-dynamic-loading-of-modules.html#G-MODULE-OPEN"
>g_module_open</A
>(),
find the module's symbols (e.g. function names) with <A
HREF="glib-dynamic-loading-of-modules.html#G-MODULE-SYMBOL"
>g_module_symbol</A
>(),
and later close the module with <A
HREF="glib-dynamic-loading-of-modules.html#G-MODULE-CLOSE"
>g_module_close</A
>().
<A
HREF="glib-dynamic-loading-of-modules.html#G-MODULE-NAME"
>g_module_name</A
>() will return the file name of a currently opened module.</P
><P
>If any of the above functions fail, the error status can be found with
<A
HREF="glib-dynamic-loading-of-modules.html#G-MODULE-ERROR"
>g_module_error</A
>().</P
><P
>The <A
HREF="glib-dynamic-loading-of-modules.html#GMODULE"
>GModule</A
> implementation features reference counting for opened modules,
and supports hook functions within a module which are called when the
module is loaded and unloaded (see <A
HREF="glib-dynamic-loading-of-modules.html#GMODULECHECKINIT"
>GModuleCheckInit</A
> and <A
HREF="glib-dynamic-loading-of-modules.html#GMODULEUNLOAD"
>GModuleUnload</A
>).</P
><P
>If your module introduces static data to common subsystems in the running
program, e.g. through calling <TT
CLASS="LITERAL"
>g_quark_from_static_string ("my-module-stuff")</TT
>,
it must ensure that it is never unloaded, by calling <A
HREF="glib-dynamic-loading-of-modules.html#G-MODULE-MAKE-RESIDENT"
>g_module_make_resident</A
>().</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN7300"
></A
><H2
>Details</H2
><DIV
CLASS="REFSECT2"
><A
NAME="AEN7302"
></A
><H3
><A
NAME="GMODULE"
></A
>struct GModule</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>struct GModule;</PRE
></TD
></TR
></TABLE
><P
>The <A
HREF="glib-dynamic-loading-of-modules.html#GMODULE"
>GModule</A
> struct is an opaque data structure to represent a
<A
HREF="glib-dynamic-loading-of-modules.html"
>Dynamically-Loaded Module</A
>.
It should only be accessed via the following functions.</P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN7309"
></A
><H3
><A
NAME="G-MODULE-SUPPORTED"
></A
>g_module_supported ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="glib-basic-types.html#GBOOLEAN"
>gboolean</A
>    g_module_supported              (void);</PRE
></TD
></TR
></TABLE
><P
>Checks if modules are supported on the current platform.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN7316"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
><TT
CLASS="LITERAL"
>TRUE</TT
> if modules are supported.
&#13;</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN7322"
></A
><H3
><A
NAME="G-MODULE-BUILD-PATH"
></A
>g_module_build_path ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>*      g_module_build_path             (const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *directory,
                                             const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *module_name);</PRE
></TD
></TR
></TABLE
><P
>A portable way to build the filename of a module. The platform-specific
prefix and suffix are added to the filename, if needed, and the result is
added to the directory, using the correct separator character.</P
><P
>The directory should specify the directory where the module can be found.
It can be <TT
CLASS="LITERAL"
>NULL</TT
> or an empty string to indicate that the module is in a standard
platform-specific directory, though this is not recommended since the
wrong module may be found.</P
><P
>For example, calling <A
HREF="glib-dynamic-loading-of-modules.html#G-MODULE-BUILD-PATH"
>g_module_build_path</A
>() on a Linux system with a <TT
CLASS="PARAMETER"
><I
>directory</I
></TT
>
of <TT
CLASS="FILENAME"
>/lib</TT
> and a <TT
CLASS="PARAMETER"
><I
>module_name</I
></TT
> of "mylibrary" will return 
<TT
CLASS="FILENAME"
>/lib/libmylibrary.so</TT
>. On a Windows system, using 
<TT
CLASS="FILENAME"
>\Windows</TT
> as the directory it will return
<TT
CLASS="FILENAME"
>\Windows\mylibrary.dll</TT
>.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN7341"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>directory</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>the directory where the module is. This can be <TT
CLASS="LITERAL"
>NULL</TT
> or the empty
string to indicate that the standard platform-specific directories will be 
used, though that is not recommended.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN7347"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>module_name</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>the name of the module.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN7352"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>the complete path of the module, including the standard library
prefix and suffix. This should be freed when no longer needed.
&#13;</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN7357"
></A
><H3
><A
NAME="G-MODULE-OPEN"
></A
>g_module_open ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="glib-dynamic-loading-of-modules.html#GMODULE"
>GModule</A
>*    g_module_open                   (const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *file_name,
                                             <A
HREF="glib-dynamic-loading-of-modules.html#GMODULEFLAGS"
>GModuleFlags</A
> flags);</PRE
></TD
></TR
></TABLE
><P
>Opens a module. If the module has already been opened, its reference
count is incremented. </P
><P
>First of all <A
HREF="glib-dynamic-loading-of-modules.html#G-MODULE-OPEN"
>g_module_open</A
>() tries to open <TT
CLASS="PARAMETER"
><I
>file_name</I
></TT
> as a module. If
that fails and <TT
CLASS="PARAMETER"
><I
>file_name</I
></TT
> has the ".la"-suffix (and is a libtool archive) 
it tries to open the corresponding module. If that fails and it doesn't 
have the proper module suffix for the platform (<A
HREF="glib-dynamic-loading-of-modules.html#G-MODULE-SUFFIX-CAPS"
>G_MODULE_SUFFIX</A
>), this 
suffix will be appended and the corresponding module will be opended. If 
that fails and <TT
CLASS="PARAMETER"
><I
>file_name</I
></TT
> doesn't have the ".la"-suffix, this suffix is 
appended and <A
HREF="glib-dynamic-loading-of-modules.html#G-MODULE-OPEN"
>g_module_open</A
>() tries to open the corresponding module. If 
eventually that fails as well, <TT
CLASS="LITERAL"
>NULL</TT
> is returned.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN7374"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>file_name</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>the name of the file containing the module.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN7379"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>flags</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>the flags used for opening the module. Currently this can be 0 or
G_MODULE_BIND_LAZY for lazy binding, where symbols are only bound when needed.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN7385"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>a <A
HREF="glib-dynamic-loading-of-modules.html#GMODULE"
>GModule</A
> on success, or <TT
CLASS="LITERAL"
>NULL</TT
> on failure.
&#13;</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN7392"
></A
><H3
><A
NAME="GMODULEFLAGS"
></A
>enum GModuleFlags</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>typedef enum
{
  G_MODULE_BIND_LAZY	= 1 &lt;&lt; 0,
  G_MODULE_BIND_MASK	= 0x01
} GModuleFlags;</PRE
></TD
></TR
></TABLE
><P
>Flags passed to <A
HREF="glib-dynamic-loading-of-modules.html#G-MODULE-OPEN"
>g_module_open</A
>().
G_MODULE_BIND_LAZY specifies that symbols are only resolved when needed.
The default action is to bind all symbols when the module is loaded.
(G_MODULE_BIND_LAZY is not supported on all platforms.)</P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN7400"
></A
><H3
><A
NAME="G-MODULE-SYMBOL"
></A
>g_module_symbol ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="glib-basic-types.html#GBOOLEAN"
>gboolean</A
>    g_module_symbol                 (<A
HREF="glib-dynamic-loading-of-modules.html#GMODULE"
>GModule</A
> *module,
                                             const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *symbol_name,
                                             <A
HREF="glib-basic-types.html#GPOINTER"
>gpointer</A
> *symbol);</PRE
></TD
></TR
></TABLE
><P
>Gets a symbol pointer from a module.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN7410"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>module</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>a <A
HREF="glib-dynamic-loading-of-modules.html#GMODULE"
>GModule</A
>.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN7416"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>symbol_name</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>the name of the symbol to find.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN7421"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>symbol</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>returns the pointer to the symbol value.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN7426"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
><TT
CLASS="LITERAL"
>TRUE</TT
> on success.
&#13;</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN7432"
></A
><H3
><A
NAME="G-MODULE-NAME"
></A
>g_module_name ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>G_CONST_RETURN <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>* g_module_name         (<A
HREF="glib-dynamic-loading-of-modules.html#GMODULE"
>GModule</A
> *module);</PRE
></TD
></TR
></TABLE
><P
>Gets the filename from a <A
HREF="glib-dynamic-loading-of-modules.html#GMODULE"
>GModule</A
>.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN7441"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>module</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>a <A
HREF="glib-dynamic-loading-of-modules.html#GMODULE"
>GModule</A
>.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN7447"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>the filename of the module, or "main" if the module is the main
program itself.
&#13;</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN7452"
></A
><H3
><A
NAME="G-MODULE-MAKE-RESIDENT"
></A
>g_module_make_resident ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void        g_module_make_resident          (<A
HREF="glib-dynamic-loading-of-modules.html#GMODULE"
>GModule</A
> *module);</PRE
></TD
></TR
></TABLE
><P
>Ensures that a module will never be unloaded.
Any future <A
HREF="glib-dynamic-loading-of-modules.html#G-MODULE-CLOSE"
>g_module_close</A
>() calls on the module will be ignored.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN7460"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>module</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>a <A
HREF="glib-dynamic-loading-of-modules.html#GMODULE"
>GModule</A
> to make permanently resident.
&#13;</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN7466"
></A
><H3
><A
NAME="G-MODULE-CLOSE"
></A
>g_module_close ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="glib-basic-types.html#GBOOLEAN"
>gboolean</A
>    g_module_close                  (<A
HREF="glib-dynamic-loading-of-modules.html#GMODULE"
>GModule</A
> *module);</PRE
></TD
></TR
></TABLE
><P
>Closes a module.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN7474"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>module</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>a <A
HREF="glib-dynamic-loading-of-modules.html#GMODULE"
>GModule</A
> to close.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN7480"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
><TT
CLASS="LITERAL"
>TRUE</TT
> on success.
&#13;</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN7486"
></A
><H3
><A
NAME="G-MODULE-ERROR"
></A
>g_module_error ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>G_CONST_RETURN <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>* g_module_error        (void);</PRE
></TD
></TR
></TABLE
><P
>Gets a string describing the last module error.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN7493"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>a string describing the last module error.
&#13;</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN7498"
></A
><H3
><A
NAME="GMODULECHECKINIT"
></A
>GModuleCheckInit ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>* (*GModuleCheckInit)            (<A
HREF="glib-dynamic-loading-of-modules.html#GMODULE"
>GModule</A
> *module);</PRE
></TD
></TR
></TABLE
><P
>Specifies the type of the module initialization function.
If a module contains a function named g_module_check_init() it is called
automatically when the module is loaded. It is passed the <A
HREF="glib-dynamic-loading-of-modules.html#GMODULE"
>GModule</A
> structure
and should return <TT
CLASS="LITERAL"
>NULL</TT
> on success or a string describing the initialization
error.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN7509"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>module</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>the <A
HREF="glib-dynamic-loading-of-modules.html#GMODULE"
>GModule</A
> corresponding to the module which has just been loaded.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN7515"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
><TT
CLASS="LITERAL"
>NULL</TT
> on success, or a string describing the initialization error.
&#13;</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN7521"
></A
><H3
><A
NAME="GMODULEUNLOAD"
></A
>GModuleUnload ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void        (*GModuleUnload)                (<A
HREF="glib-dynamic-loading-of-modules.html#GMODULE"
>GModule</A
> *module);</PRE
></TD
></TR
></TABLE
><P
>Specifies the type of the module function called when it is unloaded.
If a module contains a function named g_module_unload() it is called
automatically when the module is unloaded.
It is passed the <A
HREF="glib-dynamic-loading-of-modules.html#GMODULE"
>GModule</A
> structure.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN7530"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>module</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>the <A
HREF="glib-dynamic-loading-of-modules.html#GMODULE"
>GModule</A
> about to be unloaded.
&#13;</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN7536"
></A
><H3
><A
NAME="G-MODULE-SUFFIX-CAPS"
></A
>G_MODULE_SUFFIX</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>#define G_MODULE_SUFFIX "so"</PRE
></TD
></TR
></TABLE
><P
>Expands to the proper shared library suffix for the current platform
without the leading dot. For the most Unices and Linux this is "so",
for some HP-UX versions this is "sl" and for Windows this is "dll".</P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN7541"
></A
><H3
><A
NAME="G-MODULE-EXPORT-CAPS"
></A
>G_MODULE_EXPORT</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>#define     G_MODULE_EXPORT</PRE
></TD
></TR
></TABLE
><P
>Used to declare functions exported by modules.</P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN7546"
></A
><H3
><A
NAME="G-MODULE-IMPORT-CAPS"
></A
>G_MODULE_IMPORT</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>#define	G_MODULE_IMPORT		extern</PRE
></TD
></TR
></TABLE
><P
>Used to declare functions imported from modules.</P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><BR
CLEAR="all"><BR><TABLE
WIDTH="100%"
BORDER="0"
BGCOLOR="#000000"
CELLPADDING="1"
CELLSPACING="0"
><TR
><TD
WIDTH="25%"
BGCOLOR="#C00000"
ALIGN="left"
><A
HREF="glib-asynchronous-queues.html"
><FONT
COLOR="#FFFFFF"
SIZE="3"
><B
>&#60;&#60;&#60; Previous Page</B
></FONT
></A
></TD
><TD
WIDTH="25%"
BGCOLOR="#C00000"
ALIGN="center"
><FONT
COLOR="#FFFFFF"
SIZE="3"
><B
><A
HREF="index.html"
><FONT
COLOR="#FFFFFF"
SIZE="3"
><B
>Home</B
></FONT
></A
></B
></FONT
></TD
><TD
WIDTH="25%"
BGCOLOR="#C00000"
ALIGN="center"
><FONT
COLOR="#FFFFFF"
SIZE="3"
><B
><A
HREF="glib-core.html"
><FONT
COLOR="#FFFFFF"
SIZE="3"
><B
>Up</B
></FONT
></A
></B
></FONT
></TD
><TD
WIDTH="25%"
BGCOLOR="#C00000"
ALIGN="right"
><A
HREF="glib-memory-allocation.html"
><FONT
COLOR="#FFFFFF"
SIZE="3"
><B
>Next Page &#62;&#62;&#62;</B
></FONT
></A
></TD
></TR
><TR
><TD
COLSPAN="2"
ALIGN="left"
><FONT
COLOR="#FFFFFF"
SIZE="3"
><B
>Asynchronous Queues</B
></FONT
></TD
><TD
COLSPAN="2"
ALIGN="right"
><FONT
COLOR="#FFFFFF"
SIZE="3"
><B
>Memory Allocation</B
></FONT
></TD
></TR
></TABLE
></DIV
></BODY
></HTML
>