<HTML
><HEAD
><TITLE
>String Utility Functions</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.76b+
"><LINK
REL="HOME"
TITLE="GLib Reference Manual"
HREF="index.html"><LINK
REL="UP"
TITLE="GLib Utilities"
HREF="glib-utilities.html"><LINK
REL="PREVIOUS"
TITLE="GLib Utilities"
HREF="glib-utilities.html"><LINK
REL="NEXT"
TITLE="Character Set Conversion"
HREF="glib-character-set-conversion.html"></HEAD
><BODY
CLASS="REFENTRY"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
BGCOLOR="#000000"
CELLPADDING="1"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
><FONT
COLOR="#FFFFFF"
SIZE="5"
>GLib Reference Manual</FONT
></TH
></TR
><TR
><TD
WIDTH="25%"
BGCOLOR="#C00000"
ALIGN="left"
><A
HREF="glib-utilities.html"
><FONT
COLOR="#FFFFFF"
SIZE="3"
><B
>&#60;&#60;&#60; Previous Page</B
></FONT
></A
></TD
><TD
WIDTH="25%"
BGCOLOR="#C00000"
ALIGN="center"
><FONT
COLOR="#FFFFFF"
SIZE="3"
><B
><A
HREF="index.html"
><FONT
COLOR="#FFFFFF"
SIZE="3"
><B
>Home</B
></FONT
></A
></B
></FONT
></TD
><TD
WIDTH="25%"
BGCOLOR="#C00000"
ALIGN="center"
><FONT
COLOR="#FFFFFF"
SIZE="3"
><B
><A
HREF="glib-utilities.html"
><FONT
COLOR="#FFFFFF"
SIZE="3"
><B
>Up</B
></FONT
></A
></B
></FONT
></TD
><TD
WIDTH="25%"
BGCOLOR="#C00000"
ALIGN="right"
><A
HREF="glib-character-set-conversion.html"
><FONT
COLOR="#FFFFFF"
SIZE="3"
><B
>Next Page &#62;&#62;&#62;</B
></FONT
></A
></TD
></TR
></TABLE
></DIV
><H1
><A
NAME="GLIB-STRING-UTILITY-FUNCTIONS">String Utility Functions</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN10963"
></A
><H2
>Name</H2
>String Utility Functions&nbsp;--&nbsp;various string-related functions.</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN10966"><H2
>Synopsis</H2
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>&#13;#include &lt;glib.h&gt;


<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>*      <A
HREF="glib-string-utility-functions.html#G-STRDUP"
>g_strdup</A
>                        (const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *str);
<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>*      <A
HREF="glib-string-utility-functions.html#G-STRNDUP"
>g_strndup</A
>                       (const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *str,
                                             <A
HREF="glib-basic-types.html#GSIZE"
>gsize</A
> n);
<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>**     <A
HREF="glib-string-utility-functions.html#G-STRDUPV"
>g_strdupv</A
>                       (<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> **str_array);
<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>*      <A
HREF="glib-string-utility-functions.html#G-STRNFILL"
>g_strnfill</A
>                      (<A
HREF="glib-basic-types.html#GSIZE"
>gsize</A
> length,
                                             <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> fill_char);
<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>*      <A
HREF="glib-string-utility-functions.html#G-STPCPY"
>g_stpcpy</A
>                        (<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *dest,
                                             const char *src);
<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>*      <A
HREF="glib-string-utility-functions.html#G-STRSTR-LEN"
>g_strstr_len</A
>                    (const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *haystack,
                                             <A
HREF="glib-basic-types.html#GSSIZE"
>gssize</A
> haystack_len,
                                             const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *needle);
<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>*      <A
HREF="glib-string-utility-functions.html#G-STRRSTR"
>g_strrstr</A
>                       (const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *haystack,
                                             const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *needle);
<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>*      <A
HREF="glib-string-utility-functions.html#G-STRRSTR-LEN"
>g_strrstr_len</A
>                   (const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *haystack,
                                             <A
HREF="glib-basic-types.html#GSSIZE"
>gssize</A
> haystack_len,
                                             const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *needle);

<A
HREF="glib-basic-types.html#GSIZE"
>gsize</A
>       <A
HREF="glib-string-utility-functions.html#G-STRLCPY"
>g_strlcpy</A
>                       (<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *dest,
                                             const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *src,
                                             <A
HREF="glib-basic-types.html#GSIZE"
>gsize</A
> dest_size);
<A
HREF="glib-basic-types.html#GSIZE"
>gsize</A
>       <A
HREF="glib-string-utility-functions.html#G-STRLCAT"
>g_strlcat</A
>                       (<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *dest,
                                             const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *src,
                                             <A
HREF="glib-basic-types.html#GSIZE"
>gsize</A
> dest_size);

<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>*      <A
HREF="glib-string-utility-functions.html#G-STRDUP-PRINTF"
>g_strdup_printf</A
>                 (const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *format,
                                             ...);
<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>*      <A
HREF="glib-string-utility-functions.html#G-STRDUP-VPRINTF"
>g_strdup_vprintf</A
>                (const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *format,
                                             va_list args);
<A
HREF="glib-basic-types.html#GINT"
>gint</A
>        <A
HREF="glib-string-utility-functions.html#G-SNPRINTF"
>g_snprintf</A
>                      (<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *string,
                                             <A
HREF="glib-basic-types.html#GULONG"
>gulong</A
> n,
                                             <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> const *format,
                                             ...);
<A
HREF="glib-basic-types.html#GINT"
>gint</A
>        <A
HREF="glib-string-utility-functions.html#G-VSNPRINTF"
>g_vsnprintf</A
>                     (<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *string,
                                             <A
HREF="glib-basic-types.html#GULONG"
>gulong</A
> n,
                                             <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> const *format,
                                             va_list args);
<A
HREF="glib-basic-types.html#GSIZE"
>gsize</A
>       <A
HREF="glib-string-utility-functions.html#G-PRINTF-STRING-UPPER-BOUND"
>g_printf_string_upper_bound</A
>     (const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *format,
                                             va_list args);

<A
HREF="glib-basic-types.html#GBOOLEAN"
>gboolean</A
>    <A
HREF="glib-string-utility-functions.html#G-ASCII-ISALNUM"
>g_ascii_isalnum</A
>                 (<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> c);
<A
HREF="glib-basic-types.html#GBOOLEAN"
>gboolean</A
>    <A
HREF="glib-string-utility-functions.html#G-ASCII-ISALPHA"
>g_ascii_isalpha</A
>                 (<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> c);
<A
HREF="glib-basic-types.html#GBOOLEAN"
>gboolean</A
>    <A
HREF="glib-string-utility-functions.html#G-ASCII-ISCNTRL"
>g_ascii_iscntrl</A
>                 (<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> c);
<A
HREF="glib-basic-types.html#GBOOLEAN"
>gboolean</A
>    <A
HREF="glib-string-utility-functions.html#G-ASCII-ISDIGIT"
>g_ascii_isdigit</A
>                 (<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> c);
<A
HREF="glib-basic-types.html#GBOOLEAN"
>gboolean</A
>    <A
HREF="glib-string-utility-functions.html#G-ASCII-ISGRAPH"
>g_ascii_isgraph</A
>                 (<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> c);
<A
HREF="glib-basic-types.html#GBOOLEAN"
>gboolean</A
>    <A
HREF="glib-string-utility-functions.html#G-ASCII-ISLOWER"
>g_ascii_islower</A
>                 (<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> c);
<A
HREF="glib-basic-types.html#GBOOLEAN"
>gboolean</A
>    <A
HREF="glib-string-utility-functions.html#G-ASCII-ISPRINT"
>g_ascii_isprint</A
>                 (<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> c);
<A
HREF="glib-basic-types.html#GBOOLEAN"
>gboolean</A
>    <A
HREF="glib-string-utility-functions.html#G-ASCII-ISPUNCT"
>g_ascii_ispunct</A
>                 (<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> c);
<A
HREF="glib-basic-types.html#GBOOLEAN"
>gboolean</A
>    <A
HREF="glib-string-utility-functions.html#G-ASCII-ISSPACE"
>g_ascii_isspace</A
>                 (<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> c);
<A
HREF="glib-basic-types.html#GBOOLEAN"
>gboolean</A
>    <A
HREF="glib-string-utility-functions.html#G-ASCII-ISUPPER"
>g_ascii_isupper</A
>                 (<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> c);
<A
HREF="glib-basic-types.html#GBOOLEAN"
>gboolean</A
>    <A
HREF="glib-string-utility-functions.html#G-ASCII-ISXDIGIT"
>g_ascii_isxdigit</A
>                (<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> c);

<A
HREF="glib-basic-types.html#GINT"
>gint</A
>        <A
HREF="glib-string-utility-functions.html#G-ASCII-DIGIT-VALUE"
>g_ascii_digit_value</A
>             (<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> c);
<A
HREF="glib-basic-types.html#GINT"
>gint</A
>        <A
HREF="glib-string-utility-functions.html#G-ASCII-XDIGIT-VALUE"
>g_ascii_xdigit_value</A
>            (<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> c);

<A
HREF="glib-basic-types.html#GINT"
>gint</A
>        <A
HREF="glib-string-utility-functions.html#G-ASCII-STRCASECMP"
>g_ascii_strcasecmp</A
>              (const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *s1,
                                             const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *s2);
<A
HREF="glib-basic-types.html#GINT"
>gint</A
>        <A
HREF="glib-string-utility-functions.html#G-ASCII-STRNCASECMP"
>g_ascii_strncasecmp</A
>             (const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *s1,
                                             const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *s2,
                                             <A
HREF="glib-basic-types.html#GSIZE"
>gsize</A
> n);

<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>*      <A
HREF="glib-string-utility-functions.html#G-ASCII-STRUP"
>g_ascii_strup</A
>                   (const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *str,
                                             <A
HREF="glib-basic-types.html#GSSIZE"
>gssize</A
> len);
<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>*      <A
HREF="glib-string-utility-functions.html#G-ASCII-STRDOWN"
>g_ascii_strdown</A
>                 (const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *str,
                                             <A
HREF="glib-basic-types.html#GSSIZE"
>gssize</A
> len);

<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>       <A
HREF="glib-string-utility-functions.html#G-ASCII-TOLOWER"
>g_ascii_tolower</A
>                 (<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> c);
<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>       <A
HREF="glib-string-utility-functions.html#G-ASCII-TOUPPER"
>g_ascii_toupper</A
>                 (<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> c);

<A
HREF="glib-strings.html#GSTRING"
>GString</A
>*    <A
HREF="glib-string-utility-functions.html#G-STRING-ASCII-UP"
>g_string_ascii_up</A
>               (<A
HREF="glib-strings.html#GSTRING"
>GString</A
> *string);
<A
HREF="glib-strings.html#GSTRING"
>GString</A
>*    <A
HREF="glib-string-utility-functions.html#G-STRING-ASCII-DOWN"
>g_string_ascii_down</A
>             (<A
HREF="glib-strings.html#GSTRING"
>GString</A
> *string);

<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>*      <A
HREF="glib-string-utility-functions.html#G-STRUP"
>g_strup</A
>                         (<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *string);
<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>*      <A
HREF="glib-string-utility-functions.html#G-STRDOWN"
>g_strdown</A
>                       (<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *string);

<A
HREF="glib-basic-types.html#GINT"
>gint</A
>        <A
HREF="glib-string-utility-functions.html#G-STRCASECMP"
>g_strcasecmp</A
>                    (const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *s1,
                                             const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *s2);
<A
HREF="glib-basic-types.html#GINT"
>gint</A
>        <A
HREF="glib-string-utility-functions.html#G-STRNCASECMP"
>g_strncasecmp</A
>                   (const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *s1,
                                             const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *s2,
                                             <A
HREF="glib-basic-types.html#GUINT"
>guint</A
> n);

<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>*      <A
HREF="glib-string-utility-functions.html#G-STRREVERSE"
>g_strreverse</A
>                    (<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *string);

#define     <A
HREF="glib-string-utility-functions.html#G-ASCII-DTOSTR-BUF-SIZE-CAPS"
>G_ASCII_DTOSTR_BUF_SIZE</A
>
<A
HREF="glib-basic-types.html#GDOUBLE"
>gdouble</A
>     <A
HREF="glib-string-utility-functions.html#G-ASCII-STRTOD"
>g_ascii_strtod</A
>                  (const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *nptr,
                                             <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> **endptr);
<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>*      <A
HREF="glib-string-utility-functions.html#G-ASCII-DTOSTR"
>g_ascii_dtostr</A
>                  (<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *buffer,
                                             <A
HREF="glib-basic-types.html#GINT"
>gint</A
> buf_len,
                                             <A
HREF="glib-basic-types.html#GDOUBLE"
>gdouble</A
> d);
<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>*      <A
HREF="glib-string-utility-functions.html#G-ASCII-FORMATD"
>g_ascii_formatd</A
>                 (<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *buffer,
                                             <A
HREF="glib-basic-types.html#GINT"
>gint</A
> buf_len,
                                             const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *format,
                                             <A
HREF="glib-basic-types.html#GDOUBLE"
>gdouble</A
> d);
<A
HREF="glib-basic-types.html#GDOUBLE"
>gdouble</A
>     <A
HREF="glib-string-utility-functions.html#G-STRTOD"
>g_strtod</A
>                        (const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *nptr,
                                             <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> **endptr);

<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>*      <A
HREF="glib-string-utility-functions.html#G-STRCHUG"
>g_strchug</A
>                       (<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *string);
<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>*      <A
HREF="glib-string-utility-functions.html#G-STRCHOMP"
>g_strchomp</A
>                      (<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *string);
#define     <A
HREF="glib-string-utility-functions.html#G-STRSTRIP"
>g_strstrip</A
>                      ( string )

<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>*      <A
HREF="glib-string-utility-functions.html#G-STRDELIMIT"
>g_strdelimit</A
>                    (<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *string,
                                             const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *delimiters,
                                             <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> new_delimiter);
#define     <A
HREF="glib-string-utility-functions.html#G-STR-DELIMITERS-CAPS"
>G_STR_DELIMITERS</A
>
<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>*      <A
HREF="glib-string-utility-functions.html#G-STRESCAPE"
>g_strescape</A
>                     (const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *source,
                                             const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *exceptions);
<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>*      <A
HREF="glib-string-utility-functions.html#G-STRCOMPRESS"
>g_strcompress</A
>                   (const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *source);
<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>*      <A
HREF="glib-string-utility-functions.html#G-STRCANON"
>g_strcanon</A
>                      (<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *string,
                                             const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *valid_chars,
                                             <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> substitutor);
<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>**     <A
HREF="glib-string-utility-functions.html#G-STRSPLIT"
>g_strsplit</A
>                      (const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *string,
                                             const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *delimiter,
                                             <A
HREF="glib-basic-types.html#GINT"
>gint</A
> max_tokens);
void        <A
HREF="glib-string-utility-functions.html#G-STRFREEV"
>g_strfreev</A
>                      (<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> **str_array);
<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>*      <A
HREF="glib-string-utility-functions.html#G-STRCONCAT"
>g_strconcat</A
>                     (const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *string1,
                                             ...);
<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>*      <A
HREF="glib-string-utility-functions.html#G-STRJOIN"
>g_strjoin</A
>                       (const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *separator,
                                             ...);
<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>*      <A
HREF="glib-string-utility-functions.html#G-STRJOINV"
>g_strjoinv</A
>                      (const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *separator,
                                             <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> **str_array);

G_CONST_RETURN <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>* <A
HREF="glib-string-utility-functions.html#G-STRERROR"
>g_strerror</A
>            (<A
HREF="glib-basic-types.html#GINT"
>gint</A
> errnum);
G_CONST_RETURN <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>* <A
HREF="glib-string-utility-functions.html#G-STRSIGNAL"
>g_strsignal</A
>           (<A
HREF="glib-basic-types.html#GINT"
>gint</A
> signum);&#13;</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11183"
></A
><H2
>Description</H2
><P
>This section describes a number of utility functions for creating,
duplicating, and manipulating strings.</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN11186"
></A
><H2
>Details</H2
><DIV
CLASS="REFSECT2"
><A
NAME="AEN11188"
></A
><H3
><A
NAME="G-STRDUP"
></A
>g_strdup ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>*      g_strdup                        (const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *str);</PRE
></TD
></TR
></TABLE
><P
>Duplicates a string.
The returned string should be freed when no longer needed.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11196"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>str</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>the string to duplicate.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11201"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>a newly-allocated copy of <TT
CLASS="PARAMETER"
><I
>str</I
></TT
>.
&#13;</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN11207"
></A
><H3
><A
NAME="G-STRNDUP"
></A
>g_strndup ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>*      g_strndup                       (const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *str,
                                             <A
HREF="glib-basic-types.html#GSIZE"
>gsize</A
> n);</PRE
></TD
></TR
></TABLE
><P
>Duplicates the first <TT
CLASS="PARAMETER"
><I
>n</I
></TT
> characters of a string, returning a newly-allocated
buffer <TT
CLASS="PARAMETER"
><I
>n</I
></TT
> + 1 characters long which will always be nul-terminated.
If <TT
CLASS="PARAMETER"
><I
>str</I
></TT
> is less than <TT
CLASS="PARAMETER"
><I
>n</I
></TT
> characters long the buffer is padded with nuls.
The returned value should be freed when no longer needed.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11220"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>str</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>the string to duplicate part of.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11225"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>n</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>the maximum number of characters to copy from <TT
CLASS="PARAMETER"
><I
>str</I
></TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11231"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>a newly-allocated buffer containing the first <TT
CLASS="PARAMETER"
><I
>n</I
></TT
> characters of <TT
CLASS="PARAMETER"
><I
>str</I
></TT
>,
nul-terminated.
&#13;</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN11238"
></A
><H3
><A
NAME="G-STRDUPV"
></A
>g_strdupv ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>**     g_strdupv                       (<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> **str_array);</PRE
></TD
></TR
></TABLE
><P
>Copies <TT
CLASS="LITERAL"
>NULL</TT
>-terminated array of strings. The copy is a deep copy;
the new array should be freed by first freeing each string, then
the array itself. <A
HREF="glib-string-utility-functions.html#G-STRFREEV"
>g_strfreev</A
>() does this for you. If called
on a <TT
CLASS="LITERAL"
>NULL</TT
> value, <A
HREF="glib-string-utility-functions.html#G-STRDUPV"
>g_strdupv</A
>() simply returns <TT
CLASS="LITERAL"
>NULL</TT
>.</P
><P
>Copies a <TT
CLASS="LITERAL"
>NULL</TT
>-terminated array of strings. The result consists of a
<TT
CLASS="LITERAL"
>NULL</TT
>-terminated array, with one malloc block holding the array of strings, and
each string itself allocated. The simplest way to free the result is with
<A
HREF="glib-string-utility-functions.html#G-STRFREEV"
>g_strfreev</A
>() which frees each string in a vector, then the vector itself.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11255"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>str_array</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
> <TT
CLASS="LITERAL"
>NULL</TT
>-terminated array of strings.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11261"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
> a new <TT
CLASS="LITERAL"
>NULL</TT
>-terminated array of strings.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN11267"
></A
><H3
><A
NAME="G-STRNFILL"
></A
>g_strnfill ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>*      g_strnfill                      (<A
HREF="glib-basic-types.html#GSIZE"
>gsize</A
> length,
                                             <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> fill_char);</PRE
></TD
></TR
></TABLE
><P
>Creates a new string <TT
CLASS="PARAMETER"
><I
>length</I
></TT
> characters long filled with <TT
CLASS="PARAMETER"
><I
>fill_char</I
></TT
>.
The returned string should be freed when no longer needed.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11278"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>length</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>the length of the new string.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11283"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>fill_char</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>the character to fill the string with.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11288"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>a newly-allocated string filled the <TT
CLASS="PARAMETER"
><I
>fill_char</I
></TT
>.
&#13;</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN11294"
></A
><H3
><A
NAME="G-STPCPY"
></A
>g_stpcpy ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>*      g_stpcpy                        (<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *dest,
                                             const char *src);</PRE
></TD
></TR
></TABLE
><P
>Copies a nul-terminated string into the dest buffer, include the
trailing nul, and return a pointer to the trailing nul byte.
This is useful for concatenating multiple strings together
without having to repeatedly scan for the end.</P
><P
></P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11303"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
> destination buffer.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11308"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>src</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
> source string.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11313"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
> a pointer to trailing nul byte.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN11318"
></A
><H3
><A
NAME="G-STRSTR-LEN"
></A
>g_strstr_len ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>*      g_strstr_len                    (const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *haystack,
                                             <A
HREF="glib-basic-types.html#GSSIZE"
>gssize</A
> haystack_len,
                                             const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *needle);</PRE
></TD
></TR
></TABLE
><P
>Searches the string <TT
CLASS="PARAMETER"
><I
>haystack</I
></TT
> for the first occurrence
of the string <TT
CLASS="PARAMETER"
><I
>needle</I
></TT
>, limiting the length of the search
to <TT
CLASS="PARAMETER"
><I
>haystack_len</I
></TT
>.</P
><P
></P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11332"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>haystack</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
> a string.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11337"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>haystack_len</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
> the maximum length of <TT
CLASS="PARAMETER"
><I
>haystack</I
></TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11343"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>needle</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
> the string to search for.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11348"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
> a pointer to the found occurrence, or
   <TT
CLASS="LITERAL"
>NULL</TT
> if not found.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN11354"
></A
><H3
><A
NAME="G-STRRSTR"
></A
>g_strrstr ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>*      g_strrstr                       (const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *haystack,
                                             const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *needle);</PRE
></TD
></TR
></TABLE
><P
>Searches the string <TT
CLASS="PARAMETER"
><I
>haystack</I
></TT
> for the last occurrence
of the string <TT
CLASS="PARAMETER"
><I
>needle</I
></TT
>.</P
><P
></P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11366"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>haystack</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
> a nul-terminated string.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11371"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>needle</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
> the nul-terminated string to search for.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11376"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
> a pointer to the found occurrence, or
   <TT
CLASS="LITERAL"
>NULL</TT
> if not found.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN11382"
></A
><H3
><A
NAME="G-STRRSTR-LEN"
></A
>g_strrstr_len ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>*      g_strrstr_len                   (const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *haystack,
                                             <A
HREF="glib-basic-types.html#GSSIZE"
>gssize</A
> haystack_len,
                                             const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *needle);</PRE
></TD
></TR
></TABLE
><P
>Searches the string <TT
CLASS="PARAMETER"
><I
>haystack</I
></TT
> for the last occurrence
of the string <TT
CLASS="PARAMETER"
><I
>needle</I
></TT
>, limiting the length of the search
to <TT
CLASS="PARAMETER"
><I
>haystack_len</I
></TT
>.</P
><P
></P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11396"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>haystack</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
> a nul-terminated string.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11401"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>haystack_len</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
> the maximum length of <TT
CLASS="PARAMETER"
><I
>haystack</I
></TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11407"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>needle</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
> the nul-terminated string to search for.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11412"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
> a pointer to the found occurrence, or
   <TT
CLASS="LITERAL"
>NULL</TT
> if not found.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN11418"
></A
><H3
><A
NAME="G-STRLCPY"
></A
>g_strlcpy ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="glib-basic-types.html#GSIZE"
>gsize</A
>       g_strlcpy                       (<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *dest,
                                             const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *src,
                                             <A
HREF="glib-basic-types.html#GSIZE"
>gsize</A
> dest_size);</PRE
></TD
></TR
></TABLE
><P
>Portability wrapper that calls strlcpy() on systems which have it, and emulates
strlcpy() otherwise. Copies <TT
CLASS="PARAMETER"
><I
>src</I
></TT
> to <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>; <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
> is guaranteed to be
nul-terminated; <TT
CLASS="PARAMETER"
><I
>src</I
></TT
> must be nul-terminated; <TT
CLASS="PARAMETER"
><I
>dest_size</I
></TT
> is the buffer size, not
the number of chars to copy. Caveat: strlcpy() is supposedly more secure than
strcpy() or strncpy(), but if you really want to avoid screwups, <A
HREF="glib-string-utility-functions.html#G-STRDUP"
>g_strdup</A
>() is
an even better idea.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11439"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>destination buffer</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11444"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>src</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>source buffer</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11449"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>dest_size</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>length of <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
> in bytes</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11455"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>length of <TT
CLASS="PARAMETER"
><I
>src</I
></TT
>
&#13;</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN11461"
></A
><H3
><A
NAME="G-STRLCAT"
></A
>g_strlcat ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="glib-basic-types.html#GSIZE"
>gsize</A
>       g_strlcat                       (<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *dest,
                                             const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *src,
                                             <A
HREF="glib-basic-types.html#GSIZE"
>gsize</A
> dest_size);</PRE
></TD
></TR
></TABLE
><P
>Portability wrapper that calls <TT
CLASS="FUNCTION"
>strlcat()</TT
> on systems which have it, and emulates it otherwise. Appends nul-terminated <TT
CLASS="PARAMETER"
><I
>src</I
></TT
> string to <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>, guaranteeing
nul-termination for <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>. The total size of <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
> won't exceed
<TT
CLASS="PARAMETER"
><I
>dest_size</I
></TT
>. Caveat: this is supposedly a more secure alternative to <TT
CLASS="FUNCTION"
>strcat()</TT
> or
<TT
CLASS="FUNCTION"
>strncat()</TT
>, but for real security <A
HREF="glib-string-utility-functions.html#G-STRCONCAT"
>g_strconcat</A
>() is harder to mess up.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11483"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>destination buffer, already containing one nul-terminated string</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11488"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>src</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>source buffer</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11493"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>dest_size</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>length of <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
> buffer in bytes (not length of existing string inside <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>)</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11500"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>length of <TT
CLASS="PARAMETER"
><I
>src</I
></TT
> plus initial length of string in <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
>
&#13;</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN11507"
></A
><H3
><A
NAME="G-STRDUP-PRINTF"
></A
>g_strdup_printf ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>*      g_strdup_printf                 (const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *format,
                                             ...);</PRE
></TD
></TR
></TABLE
><P
>Similar to the standard C <TT
CLASS="FUNCTION"
>sprintf()</TT
> function
but safer, since it calculates the maximum space required and allocates
memory to hold the result.
The returned string should be freed when no longer needed.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11516"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>format</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>the standard <TT
CLASS="FUNCTION"
>sprintf()</TT
> format string.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11522"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>...</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>the parameters to insert into the format string.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11527"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>a newly-allocated string holding the result.
&#13;</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN11532"
></A
><H3
><A
NAME="G-STRDUP-VPRINTF"
></A
>g_strdup_vprintf ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>*      g_strdup_vprintf                (const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *format,
                                             va_list args);</PRE
></TD
></TR
></TABLE
><P
>Similar to the standard C <TT
CLASS="FUNCTION"
>vsprintf()</TT
> function
but safer, since it calculates the maximum space required and allocates
memory to hold the result.
The returned string should be freed when no longer needed.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11542"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>format</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>the standard <TT
CLASS="FUNCTION"
>sprintf()</TT
> format string.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11548"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>args</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>the list of parameters to insert into the format string.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11553"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>a newly-allocated string holding the result.
&#13;</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN11558"
></A
><H3
><A
NAME="G-SNPRINTF"
></A
>g_snprintf ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="glib-basic-types.html#GINT"
>gint</A
>        g_snprintf                      (<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *string,
                                             <A
HREF="glib-basic-types.html#GULONG"
>gulong</A
> n,
                                             <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> const *format,
                                             ...);</PRE
></TD
></TR
></TABLE
><P
>A safer form of the standard <TT
CLASS="FUNCTION"
>sprintf()</TT
> function.
The output is guaranteed to not exceed <TT
CLASS="PARAMETER"
><I
>n</I
></TT
> characters (including the
terminating nul character), so it is easy to ensure that a buffer overflow
cannot occur.</P
><P
>See also <A
HREF="glib-string-utility-functions.html#G-STRDUP-PRINTF"
>g_strdup_printf</A
>().</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>In versions of GLib prior to 1.2.3, this function may return -1 if the output
was truncated, and the truncated string may not be nul-terminated. 
In versions prior to 1.3.12, this function returns the length of the output 
string.</P
></BLOCKQUOTE
></DIV
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>The return value of <A
HREF="glib-string-utility-functions.html#G-SNPRINTF"
>g_snprintf</A
>() conforms to the <TT
CLASS="FUNCTION"
>snprintf()</TT
>
function as standardized in ISO C99. Note that this is different from 
traditional <TT
CLASS="FUNCTION"
>snprintf()</TT
>, which returns the length of 
the output string.</P
></BLOCKQUOTE
></DIV
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11581"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>string</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>the buffer to hold the output.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11586"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>n</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>the maximum number of characters to produce (including the terminating nul
character).</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11591"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>format</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>the format string. See the <TT
CLASS="FUNCTION"
>sprintf()</TT
>.
documentation.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11597"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>...</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>the arguments to insert in the output.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11602"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>the number of characters which would be produced if the buffer was
large enough.
&#13;</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN11607"
></A
><H3
><A
NAME="G-VSNPRINTF"
></A
>g_vsnprintf ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="glib-basic-types.html#GINT"
>gint</A
>        g_vsnprintf                     (<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *string,
                                             <A
HREF="glib-basic-types.html#GULONG"
>gulong</A
> n,
                                             <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> const *format,
                                             va_list args);</PRE
></TD
></TR
></TABLE
><P
>A safer form of the standard <TT
CLASS="FUNCTION"
>vsprintf()</TT
> function.
The output is guaranteed to not exceed <TT
CLASS="PARAMETER"
><I
>n</I
></TT
> characters (including the
terminating nul character), so it is easy to ensure that a buffer overflow
cannot occur.</P
><P
>See also <A
HREF="glib-string-utility-functions.html#G-STRDUP-VPRINTF"
>g_strdup_vprintf</A
>().</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>In versions of GLib prior to 1.2.3, this function may return -1 if the output
was truncated, and the truncated string may not be nul-terminated.
In versions prior to 1.3.12, this function returns the length of the output 
string.</P
></BLOCKQUOTE
></DIV
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>The return value of <A
HREF="glib-string-utility-functions.html#G-VSNPRINTF"
>g_vsnprintf</A
>() conforms to the <TT
CLASS="FUNCTION"
>vsnprintf()</TT
>
function as standardized in ISO C99. Note that this is different from 
traditional <TT
CLASS="FUNCTION"
>vsnprintf()</TT
>, which returns the length of 
the output string.</P
></BLOCKQUOTE
></DIV
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11631"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>string</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>the buffer to hold the output.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11636"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>n</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>the maximum number of characters to produce (including the terminating nul
character).</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11641"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>format</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>the format string. See the <TT
CLASS="FUNCTION"
>sprintf()</TT
>
documentation.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11647"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>args</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>the list of arguments to insert in the output.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11652"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>the number of characters which would be produced if the buffer was
large enough.
&#13;</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN11657"
></A
><H3
><A
NAME="G-PRINTF-STRING-UPPER-BOUND"
></A
>g_printf_string_upper_bound ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="glib-basic-types.html#GSIZE"
>gsize</A
>       g_printf_string_upper_bound     (const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *format,
                                             va_list args);</PRE
></TD
></TR
></TABLE
><P
>Calculates the maximum space needed to store the output of the
<TT
CLASS="FUNCTION"
>sprintf()</TT
> function.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11666"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>format</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>the format string. See the <TT
CLASS="FUNCTION"
>printf()</TT
>
documentation.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11672"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>args</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>the parameters to be inserted into the format string.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11677"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>the maximum space needed to store the formatted string.
&#13;</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN11682"
></A
><H3
><A
NAME="G-ASCII-ISALNUM"
></A
>g_ascii_isalnum ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="glib-basic-types.html#GBOOLEAN"
>gboolean</A
>    g_ascii_isalnum                 (<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> c);</PRE
></TD
></TR
></TABLE
><P
>Determines whether a character is alphanumeric.</P
><P
>Unlike the standard C library <TT
CLASS="FUNCTION"
>isalnum()</TT
> function, this only
recognizes standard ASCII letters and ignores the locale, returning
<TT
CLASS="LITERAL"
>FALSE</TT
> for all non-ASCII characters. Also unlike the standard
library function, this takes a <SPAN
CLASS="TYPE"
>char</SPAN
>, not an <SPAN
CLASS="TYPE"
>int</SPAN
>, 
so don't call it on <TT
CLASS="LITERAL"
>EOF</TT
> but no need to cast to <A
HREF="glib-basic-types.html#GUCHAR"
>guchar</A
> before passing a 
possibly non-ASCII character in.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11698"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>c</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>any character</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11703"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
><TT
CLASS="LITERAL"
>TRUE</TT
> if <TT
CLASS="PARAMETER"
><I
>c</I
></TT
> is an ASCII alphanumeric character
&#13;</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN11710"
></A
><H3
><A
NAME="G-ASCII-ISALPHA"
></A
>g_ascii_isalpha ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="glib-basic-types.html#GBOOLEAN"
>gboolean</A
>    g_ascii_isalpha                 (<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> c);</PRE
></TD
></TR
></TABLE
><P
>Determines whether a character is alphabetic (i.e. a letter).</P
><P
>Unlike the standard C library <TT
CLASS="FUNCTION"
>isalpha()</TT
> function, this only
recognizes standard ASCII letters and ignores the locale, returning
<TT
CLASS="LITERAL"
>FALSE</TT
> for all non-ASCII characters. Also unlike the standard
library function, this takes a <SPAN
CLASS="TYPE"
>char</SPAN
>, not an <SPAN
CLASS="TYPE"
>int</SPAN
>, 
so don't call it on <TT
CLASS="LITERAL"
>EOF</TT
> but no need to cast to <A
HREF="glib-basic-types.html#GUCHAR"
>guchar</A
> before passing a 
possibly non-ASCII character in.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11726"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>c</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>any character</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11731"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
><TT
CLASS="LITERAL"
>TRUE</TT
> if <TT
CLASS="PARAMETER"
><I
>c</I
></TT
> is an ASCII alphabetic character
&#13;</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN11738"
></A
><H3
><A
NAME="G-ASCII-ISCNTRL"
></A
>g_ascii_iscntrl ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="glib-basic-types.html#GBOOLEAN"
>gboolean</A
>    g_ascii_iscntrl                 (<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> c);</PRE
></TD
></TR
></TABLE
><P
>Determines whether a character is a control character.</P
><P
>Unlike the standard C library <TT
CLASS="FUNCTION"
>iscntrl()</TT
> function, this only
recognizes standard ASCII control characters and ignores the locale,
returning <TT
CLASS="LITERAL"
>FALSE</TT
> for all non-ASCII characters. Also unlike the standard
library function, this takes a <SPAN
CLASS="TYPE"
>char</SPAN
>, not an <SPAN
CLASS="TYPE"
>int</SPAN
>, 
so don't call it on <TT
CLASS="LITERAL"
>EOF</TT
> but no need to cast to <A
HREF="glib-basic-types.html#GUCHAR"
>guchar</A
> before passing a 
possibly non-ASCII character in.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11754"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>c</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>any character</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11759"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
><TT
CLASS="LITERAL"
>TRUE</TT
> if <TT
CLASS="PARAMETER"
><I
>c</I
></TT
> is an ASCII control character.
&#13;</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN11766"
></A
><H3
><A
NAME="G-ASCII-ISDIGIT"
></A
>g_ascii_isdigit ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="glib-basic-types.html#GBOOLEAN"
>gboolean</A
>    g_ascii_isdigit                 (<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> c);</PRE
></TD
></TR
></TABLE
><P
>Determines whether a character is digit (0-9).</P
><P
>Unlike the standard C library <TT
CLASS="FUNCTION"
>isdigit()</TT
> function,
this takes a <SPAN
CLASS="TYPE"
>char</SPAN
>, not an <SPAN
CLASS="TYPE"
>int</SPAN
>, so don't call it
on <TT
CLASS="LITERAL"
>EOF</TT
> but no need to cast to <A
HREF="glib-basic-types.html#GUCHAR"
>guchar</A
> before passing a possibly
non-ASCII character in.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11781"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>c</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>any character</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11786"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
><TT
CLASS="LITERAL"
>TRUE</TT
> if <TT
CLASS="PARAMETER"
><I
>c</I
></TT
> is an ASCII digit.
&#13;</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN11793"
></A
><H3
><A
NAME="G-ASCII-ISGRAPH"
></A
>g_ascii_isgraph ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="glib-basic-types.html#GBOOLEAN"
>gboolean</A
>    g_ascii_isgraph                 (<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> c);</PRE
></TD
></TR
></TABLE
><P
>Determines whether a character is a printing character and not a space.</P
><P
>Unlike the standard C library <TT
CLASS="FUNCTION"
>isgraph()</TT
> function, 
this only recognizes standard ASCII characters and ignores the locale, 
returning <TT
CLASS="LITERAL"
>FALSE</TT
> for all non-ASCII characters. Also unlike the standard
library function, this takes a <SPAN
CLASS="TYPE"
>char</SPAN
>, not an <SPAN
CLASS="TYPE"
>int</SPAN
>, 
so don't call it on <TT
CLASS="LITERAL"
>EOF</TT
> but no need to cast to <A
HREF="glib-basic-types.html#GUCHAR"
>guchar</A
> before passing a 
possibly non-ASCII character in.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11809"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>c</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>any character</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11814"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
><TT
CLASS="LITERAL"
>TRUE</TT
> if <TT
CLASS="PARAMETER"
><I
>c</I
></TT
> is an ASCII printing character other than space.
&#13;</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN11821"
></A
><H3
><A
NAME="G-ASCII-ISLOWER"
></A
>g_ascii_islower ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="glib-basic-types.html#GBOOLEAN"
>gboolean</A
>    g_ascii_islower                 (<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> c);</PRE
></TD
></TR
></TABLE
><P
>Determines whether a character is an ASCII lower case letter.</P
><P
>Unlike the standard C library <TT
CLASS="FUNCTION"
>islower()</TT
> function, 
this only recognizes standard ASCII letters and ignores the locale,
returning <TT
CLASS="LITERAL"
>FALSE</TT
> for all non-ASCII characters. Also unlike the standard
library function, this takes a <SPAN
CLASS="TYPE"
>char</SPAN
>, not an <SPAN
CLASS="TYPE"
>int</SPAN
>, 
so don't call it on <TT
CLASS="LITERAL"
>EOF</TT
> but no need to worry about casting to <A
HREF="glib-basic-types.html#GUCHAR"
>guchar</A
> 
before passing a possibly non-ASCII character in.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11837"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>c</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>any character</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11842"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
><TT
CLASS="LITERAL"
>TRUE</TT
> if <TT
CLASS="PARAMETER"
><I
>c</I
></TT
> is an ASCII lower case letter
&#13;</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN11849"
></A
><H3
><A
NAME="G-ASCII-ISPRINT"
></A
>g_ascii_isprint ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="glib-basic-types.html#GBOOLEAN"
>gboolean</A
>    g_ascii_isprint                 (<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> c);</PRE
></TD
></TR
></TABLE
><P
>Determines whether a character is a printing character.</P
><P
>Unlike the standard C library <TT
CLASS="FUNCTION"
>isprint()</TT
> function, 
this only recognizes standard ASCII characters and ignores the locale, 
returning <TT
CLASS="LITERAL"
>FALSE</TT
> for all non-ASCII characters. Also unlike the standard
library function, this takes a <SPAN
CLASS="TYPE"
>char</SPAN
>, not an <SPAN
CLASS="TYPE"
>int</SPAN
>, 
so don't call it on <TT
CLASS="LITERAL"
>EOF</TT
> but no need to cast to <A
HREF="glib-basic-types.html#GUCHAR"
>guchar</A
> before passing a 
possibly non-ASCII character in.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11865"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>c</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>any character</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11870"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
><TT
CLASS="LITERAL"
>TRUE</TT
> if <TT
CLASS="PARAMETER"
><I
>c</I
></TT
> is an ASCII printing character.
&#13;</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN11877"
></A
><H3
><A
NAME="G-ASCII-ISPUNCT"
></A
>g_ascii_ispunct ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="glib-basic-types.html#GBOOLEAN"
>gboolean</A
>    g_ascii_ispunct                 (<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> c);</PRE
></TD
></TR
></TABLE
><P
>Determines whether a character is a punctuation character.</P
><P
>Unlike the standard C library <TT
CLASS="FUNCTION"
>ispunct()</TT
> function, 
this only recognizes standard ASCII letters and ignores the locale, 
returning <TT
CLASS="LITERAL"
>FALSE</TT
> for all non-ASCII characters. Also unlike the standard
library function, this takes a <SPAN
CLASS="TYPE"
>char</SPAN
>, not an <SPAN
CLASS="TYPE"
>int</SPAN
>, 
so don't call it on <TT
CLASS="LITERAL"
>EOF</TT
> but no need to cast to <A
HREF="glib-basic-types.html#GUCHAR"
>guchar</A
> before passing a 
possibly non-ASCII character in.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11893"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>c</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>any character</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11898"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
><TT
CLASS="LITERAL"
>TRUE</TT
> if <TT
CLASS="PARAMETER"
><I
>c</I
></TT
> is an ASCII punctuation character.
&#13;</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN11905"
></A
><H3
><A
NAME="G-ASCII-ISSPACE"
></A
>g_ascii_isspace ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="glib-basic-types.html#GBOOLEAN"
>gboolean</A
>    g_ascii_isspace                 (<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> c);</PRE
></TD
></TR
></TABLE
><P
>Determines whether a character is a white-space character.</P
><P
>Unlike the standard C library <TT
CLASS="FUNCTION"
>isspace()</TT
> function, 
this only recognizes standard ASCII white-space and ignores the locale, 
returning <TT
CLASS="LITERAL"
>FALSE</TT
> for all non-ASCII characters. Also unlike the standard
library function, this takes a <SPAN
CLASS="TYPE"
>char</SPAN
>, not an <SPAN
CLASS="TYPE"
>int</SPAN
>, 
so don't call it on <TT
CLASS="LITERAL"
>EOF</TT
> but no need to cast to <A
HREF="glib-basic-types.html#GUCHAR"
>guchar</A
> before passing a 
possibly non-ASCII character in.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11921"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>c</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>any character</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11926"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
><TT
CLASS="LITERAL"
>TRUE</TT
> if <TT
CLASS="PARAMETER"
><I
>c</I
></TT
> is an ASCII white-space character
&#13;</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN11933"
></A
><H3
><A
NAME="G-ASCII-ISUPPER"
></A
>g_ascii_isupper ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="glib-basic-types.html#GBOOLEAN"
>gboolean</A
>    g_ascii_isupper                 (<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> c);</PRE
></TD
></TR
></TABLE
><P
>Determines whether a character is an ASCII upper case letter.</P
><P
>Unlike the standard C library <TT
CLASS="FUNCTION"
>isupper()</TT
> function, 
this only recognizes standard ASCII letters and ignores the locale, 
returning <TT
CLASS="LITERAL"
>FALSE</TT
> for all non-ASCII characters. Also unlike the standard
library function, this takes a <SPAN
CLASS="TYPE"
>char</SPAN
>, not an <SPAN
CLASS="TYPE"
>int</SPAN
>, 
so don't call it on <TT
CLASS="LITERAL"
>EOF</TT
> but no need to worry about casting to <A
HREF="glib-basic-types.html#GUCHAR"
>guchar</A
> 
before passing a possibly non-ASCII character in.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11949"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>c</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>any character</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11954"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
><TT
CLASS="LITERAL"
>TRUE</TT
> if <TT
CLASS="PARAMETER"
><I
>c</I
></TT
> is an ASCII upper case letter
&#13;</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN11961"
></A
><H3
><A
NAME="G-ASCII-ISXDIGIT"
></A
>g_ascii_isxdigit ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="glib-basic-types.html#GBOOLEAN"
>gboolean</A
>    g_ascii_isxdigit                (<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> c);</PRE
></TD
></TR
></TABLE
><P
>Determines whether a character is a hexadecimal-digit character.</P
><P
>Unlike the standard C library <TT
CLASS="FUNCTION"
>isxdigit()</TT
> function,
this takes a <SPAN
CLASS="TYPE"
>char</SPAN
>, not an <SPAN
CLASS="TYPE"
>int</SPAN
>, so
don't call it on <TT
CLASS="LITERAL"
>EOF</TT
> but no need to cast to <A
HREF="glib-basic-types.html#GUCHAR"
>guchar</A
> before passing a
possibly non-ASCII character in.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11976"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>c</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>any character</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11981"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
><TT
CLASS="LITERAL"
>TRUE</TT
> if <TT
CLASS="PARAMETER"
><I
>c</I
></TT
> is an ASCII hexadecimal-digit character.
&#13;</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN11988"
></A
><H3
><A
NAME="G-ASCII-DIGIT-VALUE"
></A
>g_ascii_digit_value ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="glib-basic-types.html#GINT"
>gint</A
>        g_ascii_digit_value             (<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> c);</PRE
></TD
></TR
></TABLE
><P
>Determines the numeric value of a character as a decimal
digit. Differs from <A
HREF="glib-unicode-manipulation.html#G-UNICHAR-DIGIT-VALUE"
>g_unichar_digit_value</A
>() because it takes
a char, so there's no worry about sign extension if characters
are signed.</P
><P
></P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN11998"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>c</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
> an ASCII character.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12003"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
> If <TT
CLASS="PARAMETER"
><I
>c</I
></TT
> is a decimal digit (according to
<A
HREF="glib-string-utility-functions.html#G-ASCII-ISDIGIT"
>g_ascii_isdigit</A
>()), its numeric value. Otherwise, -1.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN12010"
></A
><H3
><A
NAME="G-ASCII-XDIGIT-VALUE"
></A
>g_ascii_xdigit_value ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="glib-basic-types.html#GINT"
>gint</A
>        g_ascii_xdigit_value            (<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> c);</PRE
></TD
></TR
></TABLE
><P
>Determines the numeric value of a character as a hexidecimal
digit. Differs from <A
HREF="glib-unicode-manipulation.html#G-UNICHAR-XDIGIT-VALUE"
>g_unichar_xdigit_value</A
>() because it takes
a char, so there's no worry about sign extension if characters
are signed.</P
><P
></P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12020"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>c</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
> an ASCII character.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12025"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
> If <TT
CLASS="PARAMETER"
><I
>c</I
></TT
> is a hex digit (according to
<A
HREF="glib-string-utility-functions.html#G-ASCII-ISXDIGIT"
>g_ascii_isxdigit</A
>()), its numeric value. Otherwise, -1.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN12032"
></A
><H3
><A
NAME="G-ASCII-STRCASECMP"
></A
>g_ascii_strcasecmp ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="glib-basic-types.html#GINT"
>gint</A
>        g_ascii_strcasecmp              (const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *s1,
                                             const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *s2);</PRE
></TD
></TR
></TABLE
><P
>Compare two strings, ignoring the case of ASCII characters.</P
><P
>Unlike the BSD strcasecmp() function, this only recognizes standard
ASCII letters and ignores the locale, treating all non-ASCII
characters as if they are not letters.</P
><P
></P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12044"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>s1</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
> string to compare with <TT
CLASS="PARAMETER"
><I
>s2</I
></TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12050"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>s2</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
> string to compare with <TT
CLASS="PARAMETER"
><I
>s1</I
></TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12056"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
> an integer less than, equal to, or greater than
              zero if <TT
CLASS="PARAMETER"
><I
>s1</I
></TT
> is found, respectively, to be less than,
              to match, or to be greater than <TT
CLASS="PARAMETER"
><I
>s2</I
></TT
>.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN12063"
></A
><H3
><A
NAME="G-ASCII-STRNCASECMP"
></A
>g_ascii_strncasecmp ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="glib-basic-types.html#GINT"
>gint</A
>        g_ascii_strncasecmp             (const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *s1,
                                             const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *s2,
                                             <A
HREF="glib-basic-types.html#GSIZE"
>gsize</A
> n);</PRE
></TD
></TR
></TABLE
><P
>Compare <TT
CLASS="PARAMETER"
><I
>s1</I
></TT
> and <TT
CLASS="PARAMETER"
><I
>s2</I
></TT
>, ignoring the case of ASCII characters and any
characters after the first <TT
CLASS="PARAMETER"
><I
>n</I
></TT
> in each string.</P
><P
>Unlike the BSD strcasecmp() function, this only recognizes standard
ASCII letters and ignores the locale, treating all non-ASCII
characters as if they are not letters.</P
><P
></P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12079"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>s1</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
> string to compare with <TT
CLASS="PARAMETER"
><I
>s2</I
></TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12085"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>s2</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
> string to compare with <TT
CLASS="PARAMETER"
><I
>s1</I
></TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12091"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>n</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>  number of characters to compare.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12096"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
> an integer less than, equal to, or greater than zero
              if the first <TT
CLASS="PARAMETER"
><I
>n</I
></TT
> bytes of <TT
CLASS="PARAMETER"
><I
>s1</I
></TT
> is found, respectively,
              to be less than, to match, or to be greater than the
              first <TT
CLASS="PARAMETER"
><I
>n</I
></TT
> bytes of <TT
CLASS="PARAMETER"
><I
>s2</I
></TT
>.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN12105"
></A
><H3
><A
NAME="G-ASCII-STRUP"
></A
>g_ascii_strup ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>*      g_ascii_strup                   (const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *str,
                                             <A
HREF="glib-basic-types.html#GSSIZE"
>gssize</A
> len);</PRE
></TD
></TR
></TABLE
><P
>Converts all lower case ASCII letters to upper case ASCII letters.</P
><P
></P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12115"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>str</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
> a string.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12120"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>len</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
> length of <TT
CLASS="PARAMETER"
><I
>str</I
></TT
> in bytes, or -1 if <TT
CLASS="PARAMETER"
><I
>str</I
></TT
> is nul-terminated.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12127"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
> a newly allocated string, with all the lower case
              characters in <TT
CLASS="PARAMETER"
><I
>str</I
></TT
> converted to upper case, with
              semantics that exactly match <A
HREF="glib-string-utility-functions.html#G-ASCII-TOUPPER"
>g_ascii_toupper</A
>(). (Note
              that this is unlike the old <A
HREF="glib-string-utility-functions.html#G-STRUP"
>g_strup</A
>(), which modified
              the string in place.)</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN12135"
></A
><H3
><A
NAME="G-ASCII-STRDOWN"
></A
>g_ascii_strdown ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>*      g_ascii_strdown                 (const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *str,
                                             <A
HREF="glib-basic-types.html#GSSIZE"
>gssize</A
> len);</PRE
></TD
></TR
></TABLE
><P
>Converts all upper case ASCII letters to lower case ASCII letters.</P
><P
></P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12145"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>str</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
> a string.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12150"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>len</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
> length of <TT
CLASS="PARAMETER"
><I
>str</I
></TT
> in bytes, or -1 if <TT
CLASS="PARAMETER"
><I
>str</I
></TT
> is nul-terminated.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12157"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
> a newly-allocated string, with all the upper case
              characters in <TT
CLASS="PARAMETER"
><I
>str</I
></TT
> converted to lower case, with
              semantics that exactly match <A
HREF="glib-string-utility-functions.html#G-ASCII-TOLOWER"
>g_ascii_tolower</A
>(). (Note
              that this is unlike the old <A
HREF="glib-string-utility-functions.html#G-STRDOWN"
>g_strdown</A
>(), which modified
              the string in place.)</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN12165"
></A
><H3
><A
NAME="G-ASCII-TOLOWER"
></A
>g_ascii_tolower ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>       g_ascii_tolower                 (<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> c);</PRE
></TD
></TR
></TABLE
><P
>Convert a character to ASCII lower case.</P
><P
>Unlike the standard C library tolower() function, this only
recognizes standard ASCII letters and ignores the locale, returning
all non-ASCII characters unchanged, even if they are lower case
letters in a particular character set. Also unlike the standard
library function, this takes and returns a char, not an int, so
don't call it on <TT
CLASS="LITERAL"
>EOF</TT
> but no need to worry about casting to <A
HREF="glib-basic-types.html#GUCHAR"
>guchar</A
>
before passing a possibly non-ASCII character in.</P
><P
></P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12178"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>c</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
> any character.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12183"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
> the result of converting <TT
CLASS="PARAMETER"
><I
>c</I
></TT
> to lower case.
              If <TT
CLASS="PARAMETER"
><I
>c</I
></TT
> is not an ASCII upper case letter,
              <TT
CLASS="PARAMETER"
><I
>c</I
></TT
> is returned unchanged.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN12191"
></A
><H3
><A
NAME="G-ASCII-TOUPPER"
></A
>g_ascii_toupper ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>       g_ascii_toupper                 (<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> c);</PRE
></TD
></TR
></TABLE
><P
>Convert a character to ASCII upper case.</P
><P
>Unlike the standard C library toupper() function, this only
recognizes standard ASCII letters and ignores the locale, returning
all non-ASCII characters unchanged, even if they are upper case
letters in a particular character set. Also unlike the standard
library function, this takes and returns a char, not an int, so
don't call it on <TT
CLASS="LITERAL"
>EOF</TT
> but no need to worry about casting to <A
HREF="glib-basic-types.html#GUCHAR"
>guchar</A
>
before passing a possibly non-ASCII character in.</P
><P
></P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12204"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>c</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
> any character.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12209"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
> the result of converting <TT
CLASS="PARAMETER"
><I
>c</I
></TT
> to upper case.
              If <TT
CLASS="PARAMETER"
><I
>c</I
></TT
> is not an ASCII lower case letter,
              <TT
CLASS="PARAMETER"
><I
>c</I
></TT
> is returned unchanged.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN12217"
></A
><H3
><A
NAME="G-STRING-ASCII-UP"
></A
>g_string_ascii_up ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="glib-strings.html#GSTRING"
>GString</A
>*    g_string_ascii_up               (<A
HREF="glib-strings.html#GSTRING"
>GString</A
> *string);</PRE
></TD
></TR
></TABLE
><P
>Converts all lower case ASCII letters to upper case ASCII letters.</P
><P
></P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12226"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>string</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
> a GString</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12231"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
> passed-in <TT
CLASS="PARAMETER"
><I
>string</I
></TT
> pointer, with all the lower case
              characters converted to upper case in place, with
              semantics that exactly match g_ascii_toupper.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN12237"
></A
><H3
><A
NAME="G-STRING-ASCII-DOWN"
></A
>g_string_ascii_down ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="glib-strings.html#GSTRING"
>GString</A
>*    g_string_ascii_down             (<A
HREF="glib-strings.html#GSTRING"
>GString</A
> *string);</PRE
></TD
></TR
></TABLE
><P
>Converts all upper case ASCII letters to lower case ASCII letters.</P
><P
></P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12246"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>string</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
> a GString</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12251"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
> passed-in <TT
CLASS="PARAMETER"
><I
>string</I
></TT
> pointer, with all the upper case
              characters converted to lower case in place, with
              semantics that exactly match g_ascii_tolower.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN12257"
></A
><H3
><A
NAME="G-STRUP"
></A
>g_strup ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>*      g_strup                         (<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *string);</PRE
></TD
></TR
></TABLE
><DIV
CLASS="WARNING"
><P
></P
><TABLE
CLASS="WARNING"
BORDER="1"
WIDTH="100%"
><TR
><TD
ALIGN="CENTER"
><B
>Warning</B
></TD
></TR
><TR
><TD
ALIGN="LEFT"
><P
><TT
CLASS="LITERAL"
>g_strup</TT
> is deprecated and should not be used in newly-written code.</P
></TD
></TR
></TABLE
></DIV
><P
>Converts a string to upper case. This function is totally broken
for the reasons discussed in the <A
HREF="glib-string-utility-functions.html#G-STRNCASECMP"
>g_strncasecmp</A
>() docs - 
use <A
HREF="glib-string-utility-functions.html#G-ASCII-STRUP"
>g_ascii_strup</A
>() or <A
HREF="glib-unicode-manipulation.html#G-UTF8-STRUP"
>g_utf8_strup</A
>() instead.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12271"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>string</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>the string to convert.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12276"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>&#13;</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN12281"
></A
><H3
><A
NAME="G-STRDOWN"
></A
>g_strdown ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>*      g_strdown                       (<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *string);</PRE
></TD
></TR
></TABLE
><DIV
CLASS="WARNING"
><P
></P
><TABLE
CLASS="WARNING"
BORDER="1"
WIDTH="100%"
><TR
><TD
ALIGN="CENTER"
><B
>Warning</B
></TD
></TR
><TR
><TD
ALIGN="LEFT"
><P
><TT
CLASS="LITERAL"
>g_strdown</TT
> is deprecated and should not be used in newly-written code.</P
></TD
></TR
></TABLE
></DIV
><P
>Converts a string to lower case.  This function is totally broken for
the reasons discussed in the <A
HREF="glib-string-utility-functions.html#G-STRNCASECMP"
>g_strncasecmp</A
>() docs - use
<A
HREF="glib-string-utility-functions.html#G-ASCII-STRDOWN"
>g_ascii_strdown</A
>() or <A
HREF="glib-unicode-manipulation.html#G-UTF8-STRDOWN"
>g_utf8_strdown</A
>() instead.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12295"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>string</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>the string to convert.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12300"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>&#13;</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN12305"
></A
><H3
><A
NAME="G-STRCASECMP"
></A
>g_strcasecmp ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="glib-basic-types.html#GINT"
>gint</A
>        g_strcasecmp                    (const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *s1,
                                             const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *s2);</PRE
></TD
></TR
></TABLE
><DIV
CLASS="WARNING"
><P
></P
><TABLE
CLASS="WARNING"
BORDER="1"
WIDTH="100%"
><TR
><TD
ALIGN="CENTER"
><B
>Warning</B
></TD
></TR
><TR
><TD
ALIGN="LEFT"
><P
><TT
CLASS="LITERAL"
>g_strcasecmp</TT
> is deprecated and should not be used in newly-written code.</P
></TD
></TR
></TABLE
></DIV
><P
>A case-insensitive string comparison, corresponding to the standard
<TT
CLASS="FUNCTION"
>strcasecmp()</TT
> function on platforms which support it.</P
><P
>See <A
HREF="glib-string-utility-functions.html#G-STRNCASECMP"
>g_strncasecmp</A
>() for a discussion of why this is deprecated and
how to replace it.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12321"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>s1</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>a string.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12326"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>s2</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>a string to compare with <TT
CLASS="PARAMETER"
><I
>s1</I
></TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12332"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>0 if the strings match, a negative value if <TT
CLASS="PARAMETER"
><I
>s1</I
></TT
> &#60; <TT
CLASS="PARAMETER"
><I
>s2</I
></TT
>, or a positive
value if <TT
CLASS="PARAMETER"
><I
>s1</I
></TT
> &#62; <TT
CLASS="PARAMETER"
><I
>s2</I
></TT
>.
&#13;</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN12341"
></A
><H3
><A
NAME="G-STRNCASECMP"
></A
>g_strncasecmp ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="glib-basic-types.html#GINT"
>gint</A
>        g_strncasecmp                   (const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *s1,
                                             const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *s2,
                                             <A
HREF="glib-basic-types.html#GUINT"
>guint</A
> n);</PRE
></TD
></TR
></TABLE
><DIV
CLASS="WARNING"
><P
></P
><TABLE
CLASS="WARNING"
BORDER="1"
WIDTH="100%"
><TR
><TD
ALIGN="CENTER"
><B
>Warning</B
></TD
></TR
><TR
><TD
ALIGN="LEFT"
><P
><TT
CLASS="LITERAL"
>g_strncasecmp</TT
> is deprecated and should not be used in newly-written code.</P
></TD
></TR
></TABLE
></DIV
><P
>A case-insensitive string comparison, corresponding to the standard
<TT
CLASS="FUNCTION"
>strncasecmp()</TT
> function on platforms which support it.
It is similar to <A
HREF="glib-string-utility-functions.html#G-STRCASECMP"
>g_strcasecmp</A
>() except it only compares the first <TT
CLASS="PARAMETER"
><I
>n</I
></TT
> characters
of the strings.</P
><P
>The problem with <A
HREF="glib-string-utility-functions.html#G-STRNCASECMP"
>g_strncasecmp</A
>() is that it does the comparison by
calling <TT
CLASS="FUNCTION"
>toupper()</TT
>/<TT
CLASS="FUNCTION"
>tolower()</TT
> 
on each byte. <TT
CLASS="FUNCTION"
>toupper()</TT
>/<TT
CLASS="FUNCTION"
>tolower()</TT
> are
locale-specific and operate on single bytes. However, it is impossible
to handle things correctly from an i18n standpoint by operating on
bytes, since characters may be multibyte. Thus <A
HREF="glib-string-utility-functions.html#G-STRNCASECMP"
>g_strncasecmp</A
>() is
broken if your string is guaranteed to be ASCII, since it's
locale-sensitive, and it's broken if your string is localized, since
it doesn't work on many encodings at all, including UTF-8, EUC-JP,
etc.</P
><P
>There are therefore two replacement functions: <A
HREF="glib-string-utility-functions.html#G-ASCII-STRNCASECMP"
>g_ascii_strncasecmp</A
>(),
which only works on ASCII and is not locale-sensitive, and
<A
HREF="glib-unicode-manipulation.html#G-UTF8-CASEFOLD"
>g_utf8_casefold</A
>(), which is good for case-insensitive sorting of
UTF-8.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12372"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>s1</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>a string.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12377"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>s2</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>a string to compare with <TT
CLASS="PARAMETER"
><I
>s1</I
></TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12383"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>n</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>the maximum number of characters to compare.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12388"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>0 if the strings match, a negative value if <TT
CLASS="PARAMETER"
><I
>s1</I
></TT
> &#60; <TT
CLASS="PARAMETER"
><I
>s2</I
></TT
>, or a positive
value if <TT
CLASS="PARAMETER"
><I
>s1</I
></TT
> &#62; <TT
CLASS="PARAMETER"
><I
>s2</I
></TT
>.
&#13;</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN12397"
></A
><H3
><A
NAME="G-STRREVERSE"
></A
>g_strreverse ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>*      g_strreverse                    (<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *string);</PRE
></TD
></TR
></TABLE
><P
>Reverses all of the bytes in a string.
For example, <TT
CLASS="LITERAL"
>g_strreverse ("abcdef")</TT
> will result in "fedcba".</P
><P
>Note that <A
HREF="glib-string-utility-functions.html#G-STRREVERSE"
>g_strreverse</A
>() doesn't work on UTF-8 strings containing multibyte characters.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12408"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>string</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>the string to reverse.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12413"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>the same pointer passed in as <TT
CLASS="PARAMETER"
><I
>string</I
></TT
>.
&#13;</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN12419"
></A
><H3
><A
NAME="G-ASCII-DTOSTR-BUF-SIZE-CAPS"
></A
>G_ASCII_DTOSTR_BUF_SIZE</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>#define G_ASCII_DTOSTR_BUF_SIZE (29 + 10)</PRE
></TD
></TR
></TABLE
><P
>A good size for a buffer to be passed into <A
HREF="glib-string-utility-functions.html#G-ASCII-DTOSTR"
>g_ascii_dtostr</A
>().
It is guaranteed to be enough for all output of that function on systems with
 64bit IEEE-compatible doubles.</P
><P
>The typical usage would be something like:
<DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN12426"><P
></P
><TABLE
BORDER="0"
BGCOLOR="#D8F8D8"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>  char buf[G_ASCII_DTOSTR_BUF_SIZE];

  fprintf (out, "value=<TT
CLASS="LITERAL"
>s</TT
>\n", g_ascii_dtostr (buf, sizeof (buf), value));</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
></P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN12429"
></A
><H3
><A
NAME="G-ASCII-STRTOD"
></A
>g_ascii_strtod ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="glib-basic-types.html#GDOUBLE"
>gdouble</A
>     g_ascii_strtod                  (const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *nptr,
                                             <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> **endptr);</PRE
></TD
></TR
></TABLE
><P
>Converts a string to a <A
HREF="glib-basic-types.html#GDOUBLE"
>gdouble</A
> value.
This function behaves like the standard strtod() function
does in the C locale. It does this without actually
changing the current locale, since that would not be
thread-safe.</P
><P
>This function is typically used when reading configuration
files or other non-user input that should be locale independent.
To handle input from the user you should normally use the
locale-sensitive system strtod() function.</P
><P
>To convert from a string to <A
HREF="glib-basic-types.html#GDOUBLE"
>gdouble</A
> in a locale-insensitive
way, use <A
HREF="glib-string-utility-functions.html#G-ASCII-DTOSTR"
>g_ascii_dtostr</A
>().</P
><P
>If the correct value would cause overflow, plus or minus <TT
CLASS="LITERAL"
>HUGE_VAL</TT
>
is returned (according to the sign of the value), and <TT
CLASS="LITERAL"
>ERANGE</TT
> is
stored in <TT
CLASS="LITERAL"
>errno</TT
>. If the correct value would cause underflow,
zero is returned and <TT
CLASS="LITERAL"
>ERANGE</TT
> is stored in <TT
CLASS="LITERAL"
>errno</TT
>.</P
><P
>This function resets <TT
CLASS="LITERAL"
>errno</TT
> before calling strtod() so that
you can reliably detect overflow and underflow.</P
><P
></P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12455"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>nptr</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>    the string to convert to a numeric value.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12460"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>endptr</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>  if non-<TT
CLASS="LITERAL"
>NULL</TT
>, it returns the character after
          the last character used in the conversion.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12466"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
> the <A
HREF="glib-basic-types.html#GDOUBLE"
>gdouble</A
> value.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN12472"
></A
><H3
><A
NAME="G-ASCII-DTOSTR"
></A
>g_ascii_dtostr ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>*      g_ascii_dtostr                  (<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *buffer,
                                             <A
HREF="glib-basic-types.html#GINT"
>gint</A
> buf_len,
                                             <A
HREF="glib-basic-types.html#GDOUBLE"
>gdouble</A
> d);</PRE
></TD
></TR
></TABLE
><P
>Converts a <A
HREF="glib-basic-types.html#GDOUBLE"
>gdouble</A
> to a string, using the '.' as
decimal point. </P
><P
>This functions generates enough precision that converting
the string back using <A
HREF="glib-string-utility-functions.html#G-STRTOD"
>g_strtod</A
>() gives the same machine-number
(on machines with IEEE compatible 64bit doubles). It is
guaranteed that the size of the resulting string will never
be larger than <TT
CLASS="PARAMETER"
><I
>G_ASCII_DTOSTR_BUF_SIZE</I
></TT
> bytes.</P
><P
></P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12487"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>buffer</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
> A buffer to place the resulting string in</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12492"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>buf_len</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
> The length of the buffer.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12497"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>d</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
> The <A
HREF="glib-basic-types.html#GDOUBLE"
>gdouble</A
> to convert</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12503"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
> The pointer to the buffer with the converted string.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN12508"
></A
><H3
><A
NAME="G-ASCII-FORMATD"
></A
>g_ascii_formatd ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>*      g_ascii_formatd                 (<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *buffer,
                                             <A
HREF="glib-basic-types.html#GINT"
>gint</A
> buf_len,
                                             const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *format,
                                             <A
HREF="glib-basic-types.html#GDOUBLE"
>gdouble</A
> d);</PRE
></TD
></TR
></TABLE
><P
>Converts a <A
HREF="glib-basic-types.html#GDOUBLE"
>gdouble</A
> to a string, using the '.' as
decimal point. To format the number you pass in
a printf-style formating string. Allowed conversion
specifiers are 'e', 'E', 'f', 'F', 'g' and 'G'. </P
><P
>If you just want to want to serialize the value into a
string, use <A
HREF="glib-string-utility-functions.html#G-ASCII-DTOSTR"
>g_ascii_dtostr</A
>().</P
><P
></P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12523"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>buffer</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
> A buffer to place the resulting string in</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12528"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>buf_len</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
> The length of the buffer.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12533"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>format</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
> The printf-style format to use for the
         code to use for converting. </P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12538"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>d</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
> The <A
HREF="glib-basic-types.html#GDOUBLE"
>gdouble</A
> to convert</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12544"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
> The pointer to the buffer with the converted string.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN12549"
></A
><H3
><A
NAME="G-STRTOD"
></A
>g_strtod ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="glib-basic-types.html#GDOUBLE"
>gdouble</A
>     g_strtod                        (const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *nptr,
                                             <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> **endptr);</PRE
></TD
></TR
></TABLE
><P
>Converts a string to a <A
HREF="glib-basic-types.html#GDOUBLE"
>gdouble</A
> value.
It calls the standard strtod() function to handle the conversion, but
if the string is not completely converted it attempts the conversion
again with <A
HREF="glib-string-utility-functions.html#G-ASCII-STRTOD"
>g_ascii_strtod</A
>(), and returns the best match.</P
><P
>This function should seldomly be used. The normal situation when reading
numbers not for human consumption is to use <A
HREF="glib-string-utility-functions.html#G-ASCII-STRTOD"
>g_ascii_strtod</A
>(). Only when
you know that you must expect both locale formatted and C formatted numbers
should you use this. Make sure that you don't pass strings such as comma
separated lists of values, since the commas may be interpreted as a decimal
point in some locales, causing unexpected results.</P
><P
></P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12564"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>nptr</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>    the string to convert to a numeric value.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12569"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>endptr</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>  if non-<TT
CLASS="LITERAL"
>NULL</TT
>, it returns the character after
          the last character used in the conversion.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12575"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
> the <A
HREF="glib-basic-types.html#GDOUBLE"
>gdouble</A
> value.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN12581"
></A
><H3
><A
NAME="G-STRCHUG"
></A
>g_strchug ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>*      g_strchug                       (<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *string);</PRE
></TD
></TR
></TABLE
><P
>Removes leading whitespace from a string, by moving the rest of the
characters forward.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12589"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>string</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>a string to remove the leading whitespace from.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12594"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
><TT
CLASS="PARAMETER"
><I
>string</I
></TT
>.
&#13;</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN12600"
></A
><H3
><A
NAME="G-STRCHOMP"
></A
>g_strchomp ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>*      g_strchomp                      (<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *string);</PRE
></TD
></TR
></TABLE
><P
>Removes trailing whitespace from a string.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12608"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>string</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>a string to remove the trailing whitespace from.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12613"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
><TT
CLASS="PARAMETER"
><I
>string</I
></TT
>.
&#13;</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN12619"
></A
><H3
><A
NAME="G-STRSTRIP"
></A
>g_strstrip()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>#define     g_strstrip( string )</PRE
></TD
></TR
></TABLE
><P
>Removes leading and trailing whitespace from a string.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12625"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>string</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>a string to remove the leading and trailing whitespace from.
&#13;</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN12630"
></A
><H3
><A
NAME="G-STRDELIMIT"
></A
>g_strdelimit ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>*      g_strdelimit                    (<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *string,
                                             const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *delimiters,
                                             <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> new_delimiter);</PRE
></TD
></TR
></TABLE
><P
>Converts any delimiter characters in <TT
CLASS="PARAMETER"
><I
>string</I
></TT
> to <TT
CLASS="PARAMETER"
><I
>new_delimiter</I
></TT
>.
Any characters in <TT
CLASS="PARAMETER"
><I
>string</I
></TT
> which are found in <TT
CLASS="PARAMETER"
><I
>delimiters</I
></TT
> are changed
to the <TT
CLASS="PARAMETER"
><I
>new_delimiter</I
></TT
> character.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12645"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>string</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>the string to convert.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12650"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>delimiters</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>a string containing the current delimiters, or <TT
CLASS="LITERAL"
>NULL</TT
> to use the
standard delimiters defined in <A
HREF="glib-string-utility-functions.html#G-STR-DELIMITERS-CAPS"
>G_STR_DELIMITERS</A
>.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12657"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>new_delimiter</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>the new delimiter character.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12662"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>&#13;</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN12667"
></A
><H3
><A
NAME="G-STR-DELIMITERS-CAPS"
></A
>G_STR_DELIMITERS</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>#define	 G_STR_DELIMITERS	"_-|&gt; &lt;."</PRE
></TD
></TR
></TABLE
><P
>The standard delimiters, used in <A
HREF="glib-string-utility-functions.html#G-STRDELIMIT"
>g_strdelimit</A
>().</P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN12673"
></A
><H3
><A
NAME="G-STRESCAPE"
></A
>g_strescape ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>*      g_strescape                     (const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *source,
                                             const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *exceptions);</PRE
></TD
></TR
></TABLE
><P
>Escapes the special characters '\b', '\f', '\n', '\r', '\t', '\' and
'&quot;' in the string <TT
CLASS="PARAMETER"
><I
>source</I
></TT
> by inserting a '\' before
them. Additionally all characters in the range 0x01-0x1F (everything
below SPACE) and in the range 0x80-0xFF (all non-ASCII chars) are
replaced with a '\' followed by their octal representation. Characters
supplied in <TT
CLASS="PARAMETER"
><I
>exceptions</I
></TT
> are not escaped.</P
><P
><A
HREF="glib-string-utility-functions.html#G-STRCOMPRESS"
>g_strcompress</A
>() does the reverse conversion.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12686"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>source</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>a string to escape.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12691"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>exceptions</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>a string of characters not to escape in <TT
CLASS="PARAMETER"
><I
>source</I
></TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12697"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>a newly-allocated copy of <TT
CLASS="PARAMETER"
><I
>source</I
></TT
> with certain
characters escaped. See above.
&#13;</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN12703"
></A
><H3
><A
NAME="G-STRCOMPRESS"
></A
>g_strcompress ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>*      g_strcompress                   (const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *source);</PRE
></TD
></TR
></TABLE
><P
>Replaces all escaped characters with their one byte equivalent. It
does the reverse conversion of <A
HREF="glib-string-utility-functions.html#G-STRESCAPE"
>g_strescape</A
>(). </P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12712"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>source</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>a string to compress.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12717"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>a newly-allocated copy of <TT
CLASS="PARAMETER"
><I
>source</I
></TT
> with all escaped 
character compressed.
&#13;</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN12723"
></A
><H3
><A
NAME="G-STRCANON"
></A
>g_strcanon ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>*      g_strcanon                      (<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *string,
                                             const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *valid_chars,
                                             <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> substitutor);</PRE
></TD
></TR
></TABLE
><P
>For each character in <TT
CLASS="PARAMETER"
><I
>string</I
></TT
>, if the character is not in <TT
CLASS="PARAMETER"
><I
>valid_chars</I
></TT
>,
replaces the character with <TT
CLASS="PARAMETER"
><I
>substitutor</I
></TT
>. Modifies <TT
CLASS="PARAMETER"
><I
>string</I
></TT
> in place, 
and return <TT
CLASS="PARAMETER"
><I
>string</I
></TT
> itself, not a copy. The return value is to allow
nesting such as <TT
CLASS="LITERAL"
>g_ascii_strup (g_strcanon (str, "abc", '?'))</TT
>.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12739"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>string</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>a nul-terminated array of bytes.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12744"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>valid_chars</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>bytes permitted in <TT
CLASS="PARAMETER"
><I
>string</I
></TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12750"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>substitutor</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>replacement character for disallowed bytes.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12755"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
><TT
CLASS="PARAMETER"
><I
>string</I
></TT
>.
&#13;</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN12761"
></A
><H3
><A
NAME="G-STRSPLIT"
></A
>g_strsplit ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>**     g_strsplit                      (const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *string,
                                             const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *delimiter,
                                             <A
HREF="glib-basic-types.html#GINT"
>gint</A
> max_tokens);</PRE
></TD
></TR
></TABLE
><P
>Splits a string into a maximum of <TT
CLASS="PARAMETER"
><I
>max_tokens</I
></TT
> pieces, using the given
<TT
CLASS="PARAMETER"
><I
>delimiter</I
></TT
>. If <TT
CLASS="PARAMETER"
><I
>max_tokens</I
></TT
> is reached, the remainder of <TT
CLASS="PARAMETER"
><I
>string</I
></TT
> is appended
to the last token. </P
><P
>As a special case, the result of splitting the empty string "" is an empty
vector, not a vector containing a single string. The reason for this
special case is that being able to represent a empty vector is typically
more useful than consistent handling of empty elements. If you do need
to represent empty elements, you'll need to check for the empty string
before calling <A
HREF="glib-string-utility-functions.html#G-STRSPLIT"
>g_strsplit</A
>().</P
><P
></P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12778"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>string</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
> a string to split.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12783"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>delimiter</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
> a string which specifies the places at which to split the string.
    The delimiter is not included in any of the resulting strings, unless
    <TT
CLASS="PARAMETER"
><I
>max_tokens</I
></TT
> is reached.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12789"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>max_tokens</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
> the maximum number of pieces to split <TT
CLASS="PARAMETER"
><I
>string</I
></TT
> into. If this is
             less than 1, the string is split completely.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12795"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
> a newly-allocated <TT
CLASS="LITERAL"
>NULL</TT
>-terminated array of strings. Use 
   <A
HREF="glib-string-utility-functions.html#G-STRFREEV"
>g_strfreev</A
>() to free it.</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN12802"
></A
><H3
><A
NAME="G-STRFREEV"
></A
>g_strfreev ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void        g_strfreev                      (<A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> **str_array);</PRE
></TD
></TR
></TABLE
><P
>Frees a <TT
CLASS="LITERAL"
>NULL</TT
>-terminated array of strings, and the array itself.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12810"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>str_array</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>a <TT
CLASS="LITERAL"
>NULL</TT
>-terminated array of strings to free.
&#13;</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN12816"
></A
><H3
><A
NAME="G-STRCONCAT"
></A
>g_strconcat ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>*      g_strconcat                     (const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *string1,
                                             ...);</PRE
></TD
></TR
></TABLE
><P
>Concatenates all of the given strings into one long string.  The returned string
should be freed when no longer needed.  WARNING: THE VARIABLE ARGUMENT LIST MUST
END WITH <TT
CLASS="LITERAL"
>NULL</TT
>. If you forget the <TT
CLASS="LITERAL"
>NULL</TT
>, <A
HREF="glib-string-utility-functions.html#G-STRCONCAT"
>g_strconcat</A
>() will start appending
random memory junk to your string.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12827"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>string1</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>The first string to add, which must not be <TT
CLASS="LITERAL"
>NULL</TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12833"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>...</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>a <TT
CLASS="LITERAL"
>NULL</TT
>-terminated list of strings to append to the string.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12839"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>a newly-allocated string containing all the string arguments.
&#13;</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN12844"
></A
><H3
><A
NAME="G-STRJOIN"
></A
>g_strjoin ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>*      g_strjoin                       (const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *separator,
                                             ...);</PRE
></TD
></TR
></TABLE
><P
>Joins a number of strings together to form one long string, with the optional
<TT
CLASS="PARAMETER"
><I
>separator</I
></TT
> inserted between each of them.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12853"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>separator</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>a string to insert between each of the strings, or <TT
CLASS="LITERAL"
>NULL</TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12859"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>...</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>a <TT
CLASS="LITERAL"
>NULL</TT
>-terminated list of strings to join.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12865"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>a newly-allocated string containing all of the strings joined
together, with <TT
CLASS="PARAMETER"
><I
>separator</I
></TT
> between them.
&#13;</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN12871"
></A
><H3
><A
NAME="G-STRJOINV"
></A
>g_strjoinv ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>*      g_strjoinv                      (const <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> *separator,
                                             <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
> **str_array);</PRE
></TD
></TR
></TABLE
><P
>Joins a number of strings together to form one long string, with the optional
<TT
CLASS="PARAMETER"
><I
>separator</I
></TT
> inserted between each of them.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12881"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>separator</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>a string to insert between each of the strings, or <TT
CLASS="LITERAL"
>NULL</TT
>.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12887"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>str_array</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>a <TT
CLASS="LITERAL"
>NULL</TT
>-terminated array of strings to join.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12893"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>a newly-allocated string containing all of the strings joined
together, with <TT
CLASS="PARAMETER"
><I
>separator</I
></TT
> between them.
&#13;</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN12899"
></A
><H3
><A
NAME="G-STRERROR"
></A
>g_strerror ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>G_CONST_RETURN <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>* g_strerror            (<A
HREF="glib-basic-types.html#GINT"
>gint</A
> errnum);</PRE
></TD
></TR
></TABLE
><P
>Returns a string corresponding to the given error code, e.g. "no such process".
This function is included since not all platforms support the 
<TT
CLASS="FUNCTION"
>strerror()</TT
> function.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12909"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>errnum</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>the system error number. See the standard C <TT
CLASS="LITERAL"
>errno</TT
>
documentation.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12915"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>a string describing the error code.
If the error code is unknown, it returns "unknown error (&lt;code&gt;)".
The string can only be used until the next call to g_strerror.
&#13;</P
></TD
></TR
></TBODY
></TABLE
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN12920"
></A
><H3
><A
NAME="G-STRSIGNAL"
></A
>g_strsignal ()</H3
><TABLE
BORDER="0"
BGCOLOR="#E8E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>G_CONST_RETURN <A
HREF="glib-basic-types.html#GCHAR"
>gchar</A
>* g_strsignal           (<A
HREF="glib-basic-types.html#GINT"
>gint</A
> signum);</PRE
></TD
></TR
></TABLE
><P
>Returns a string describing the given signal, e.g. "Segmentation fault".
This function is included since not all platforms support the
<TT
CLASS="FUNCTION"
>strsignal()</TT
> function.</P
><P
></P
><TABLE
CLASS="VARIABLELIST"
BORDER="0"
CELLSPACING="0"
CELLPADDING="4"
WIDTH="100%"
BGCOLOR="#F0F0D0"
><TBODY
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12930"><SPAN
STYLE="white-space: nowrap"
><TT
CLASS="PARAMETER"
><I
>signum</I
></TT
>&nbsp;:</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>the signal number. See the <TT
CLASS="LITERAL"
>signal</TT
>
documentation.</P
></TD
></TR
><TR
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="20%"
><A
NAME="AEN12936"><SPAN
STYLE="white-space: nowrap"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Returns</I
></SPAN
> :</SPAN
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="80%"
><P
>a string describing the signal.
If the signal is unknown, it returns "unknown signal (&lt;signum&gt;)".
The string can only be used until the next call to g_strsignal.
&#13;</P
></TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><BR
CLEAR="all"><BR><TABLE
WIDTH="100%"
BORDER="0"
BGCOLOR="#000000"
CELLPADDING="1"
CELLSPACING="0"
><TR
><TD
WIDTH="25%"
BGCOLOR="#C00000"
ALIGN="left"
><A
HREF="glib-utilities.html"
><FONT
COLOR="#FFFFFF"
SIZE="3"
><B
>&#60;&#60;&#60; Previous Page</B
></FONT
></A
></TD
><TD
WIDTH="25%"
BGCOLOR="#C00000"
ALIGN="center"
><FONT
COLOR="#FFFFFF"
SIZE="3"
><B
><A
HREF="index.html"
><FONT
COLOR="#FFFFFF"
SIZE="3"
><B
>Home</B
></FONT
></A
></B
></FONT
></TD
><TD
WIDTH="25%"
BGCOLOR="#C00000"
ALIGN="center"
><FONT
COLOR="#FFFFFF"
SIZE="3"
><B
><A
HREF="glib-utilities.html"
><FONT
COLOR="#FFFFFF"
SIZE="3"
><B
>Up</B
></FONT
></A
></B
></FONT
></TD
><TD
WIDTH="25%"
BGCOLOR="#C00000"
ALIGN="right"
><A
HREF="glib-character-set-conversion.html"
><FONT
COLOR="#FFFFFF"
SIZE="3"
><B
>Next Page &#62;&#62;&#62;</B
></FONT
></A
></TD
></TR
><TR
><TD
COLSPAN="2"
ALIGN="left"
><FONT
COLOR="#FFFFFF"
SIZE="3"
><B
>GLib Utilities</B
></FONT
></TD
><TD
COLSPAN="2"
ALIGN="right"
><FONT
COLOR="#FFFFFF"
SIZE="3"
><B
>Character Set Conversion</B
></FONT
></TD
></TR
></TABLE
></DIV
></BODY
></HTML
>